#!/bin/bash
set -o noglob
shopt -qs extglob

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
readonly projectDir="${scriptDir}/.."
readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"
customActionsDirspec="${projectDir}/etc/custom"
definitionDirspec="${projectDir}/etc/definitions"

SUDO='sudo --set-home'; [ $EUID -eq 0 ] && SUDO=''  # Use root's home; especially pip3 writes to ~/.cache/pip and complains if the files belong to another user.

printUsage()
{
    cat <<HELPTEXT
Guided wizard to install various common software that I use.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-v|--verbose] -a|--all|DEFINITION-NAME|FILESPEC [...] [-?|-h|--help]'
}

typeset -a acceptedDefinitions=()
addAllAcceptedDefinitions()
{
    local definition; while IFS=$'\n' read -r definition
    do
	definition="${definition#./}"
	memoizeDecision --memoize-group setup-software-definitions --subject "$definition" --verb 'is not' --state 'chosen' --action 'consider it' && \
	    acceptedDefinitions+=("$definition")
    done < <(cd "$definitionDirspec" && find . -type f -print | sort)
}

database()
{
    picoDB --base-type data --namespace setup-software --table "$@"
}

isVerbose=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--verbose|-v)	shift; isVerbose=t;;
	--all|-a)	shift
			addAllAcceptedDefinitions
			if [ ${#acceptedDefinitions[@]} -eq 0 ]; then
			    exit 1
			else
			    set -- "${acceptedDefinitions[@]}" "$@"
			fi
			;;
	--database)	shift; database "$@"; exit $?;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

IFS=' '

typeset -A installedPackages=()
isInstalledPackagesAvailable=
getInstalledPackages()
{
    [ "$isInstalledPackagesAvailable" ] && return

    local package; while IFS=$'\n' read -r package
    do
	installedPackages["$package"]=t
	case ",${DEBUG:-}," in *,setup-software:pkg,*) echo >&2 "${PS4}setup-software (pkg): Found installed ${package}";; esac
    done < <(dpkg-package-list)

    if [ ${#installedPackages[@]} -eq 0 ]; then
	echo >&2 'ERROR: Failed to obtain installed package list.'
	exit 3
    fi

    isInstalledPackagesAvailable=t
}

typeset -A installedPpaRepositories=()
isInstalledPpaRepositoriesAvailable=
getInstalledPpaRepositories()
{
    [ "$isInstalledPpaRepositoriesAvailable" ] && return

    local repo; while IFS=$'\n' read -r repo
    do
	installedPpaRepositories["${repo#ppa:}"]=t
	case ",${DEBUG:-}," in *,setup-software:ppa,*) echo >&2 "${PS4}setup-software (ppa): Found installed ppa:${repo}";; esac
    done < <(apt-list-repositories --ppa-only)

    isInstalledPpaRepositoriesAvailable=t
}

typeset -A installedDebBuildDependencies=()
isInstalledDebBuildDependenciesAvailable=
getInstalledDebBuildDependencies()
{
    [ "$isInstalledDebBuildDependenciesAvailable" ] && return

    eval "$(database debBuildDependencies --get-as-dictionary installedDebBuildDependencies)" || exit 3

    [ ${#installedDebBuildDependencies[@]} -gt 0 ] &&
	case ",${DEBUG:-}," in *,setup-software:deb-build,*) echo >&2 "${PS4}setup-software (deb-build): Found installed ${!installedDebBuildDependencies[@]}";; esac

    isInstalledDebBuildDependenciesAvailable=t
}

# deb+url definitions consist of a [[SUBDIR/]NAME/]PACKAGE-GLOB:URL pair.
# If ~/install/(SUBDIR|*)/(NAME|*)/PACKAGE-GLOB already exists, it will be used; else, the *.deb
# from URL will be downloaded (and put into ~/install/* if it exists).

typeset -A installedSnapPackages=()
isInstalledSnapPackagesAvailable=
getInstalledSnapPackages()
{
    [ "$isInstalledSnapPackagesAvailable" ] && return

    local packageName remainder; while IFS=' ' read -r packageName remainder
    do
	case "$packageName" in
	    Name)	    continue;;	# Skip single-line header
	    *)		    installedSnapPackages["$packageName"]=t
			    case ",${DEBUG:-}," in *,setup-software:snap,*) echo >&2 "${PS4}setup-software (snap): Found installed ${packageName}";; esac
			    ;;
	esac
    done < <(snap list --color=never --unicode=never 2>/dev/null)

    isInstalledSnapPackagesAvailable=t
}

typeset -A installedPip3Packages=()
isInstalledPip3PackagesAvailable=
getInstalledPip3Packages()
{
    [ "$isInstalledPip3PackagesAvailable" ] && return

    local packageName remainder; while IFS=' ' read -r packageName remainder
    do
	case "$packageName" in
	    Package|+(-))   continue;;	# Skip 2-line header
	    *)		    installedPip3Packages["$packageName"]=t
			    case ",${DEBUG:-}," in *,setup-software:pip3,*) echo >&2 "${PS4}setup-software (pip3): Found installed ${packageName}";; esac
			    ;;
	esac
    done < <(pip3 list 2>/dev/null)

    isInstalledPip3PackagesAvailable=t
}

typeset -A installedNpmPackages=()
isInstalledNpmPackagesAvailable=
getInstalledNpmPackages()
{
    [ "$isInstalledNpmPackagesAvailable" ] && return

    local packageDirspec; while IFS=$'\n' read -r packageDirspec
    do
	local packageName; packageName="${packageDirspec##*/}"
	if [ -n "$packageName" ]; then
	    installedNpmPackages["$packageName"]=t
	    case ",${DEBUG:-}," in *,setup-software:npm,*) echo >&2 "${PS4}setup-software (npm): Found installed ${packageName}";; esac
	fi
    done < <(npm --global --parseable --depth 0 2>/dev/null)

    isInstalledNpmPackagesAvailable=t
}

# Custom definitions consist of a CHECK:ACTION pair.
# CHECK can be one of the following (in decreasing precedence):
# - an EXECUTABLE-COMMAND in the ./etc/custom directory tree that is called and
#   should succeed if the application already exists, and fail if it is missing;
#   if EXECUTABLE-COMMAND starts with a &, this is replaced by the following
#   ACTION (without a $SUDO prefix), allowing you to save repeated typing:
#	custom:&-check:foo-installer
# - an EXECUTABLE-NAME? (located through $PATH) or FILESPEC?, and succeeds if
#   it's there
# - a TEST-EXPRESSION that is eval'd and should succeed if the application
#   already exists, and fail if it is missing; if TEST-EXPRESSION starts with a
#   &, this is replaced by the following ACTION (without a $SUDO prefix),
#   allowing you to re-use the same script for checking and installing:
#	custom:& --check:foo-installer
#   or save repeated typing:
#	custom:&-check:foo-installer
# ACTION is one of the following:
# - an executable command in the ./etc/custom directory tree that is invoked
#   (prepend $SUDO if it needs to be invoked as root) and should then install
#   the application
# - an INSTALL-EXPRESSION that is eval'd (prepend $SUDO if it needs to be
#   invoked as root)
customCheck()
{
    local customAction="${1#*:}"
    local customCheck="${1%:$customAction}"
    local customActionWithoutSudo="${customAction#\$SUDO }"

    if [ -z "$customAction" -o -z "$customCheck" ]; then
	printf >&2 'ERROR: Invalid custom definition: "custom:%s"\n' "$1"
	exit 3
    fi

    if [ -x "${customActionsDirspec}/${customCheck}" ]; then
	"${customActionsDirspec}/${customCheck}"
    elif [[ "$customCheck" =~ \?$ ]] && local customCheckLikeAction="${customActionsDirspec}/${customActionWithoutSudo}${customCheck#\&}" && [ -x "$customCheckLikeAction" ]; then
	"$customCheckLikeAction"
    elif [[ "$customCheck" =~ \?$ ]]; then
	which "${customCheck%\?}" >/dev/null 2>&1
    else
	if [[ "$customCheck" =~ ^\& ]]; then
	    customCheck="${customActionWithoutSudo}${customCheck#\&}"
	fi

	eval "$customCheck"
    fi
}


hasItem()
{
    local item="${1:?}"; shift
    local name="${item#*:}"
    local prefix="${item%$name}"

    case "$prefix" in
	# If a package retrieval fails, treat this as an existing item, so that
	# these are effectively skipped.
	'')		! getInstalledPackages			|| [ "${installedPackages["$name"]}" ];;
	ppa:)		! getInstalledPpaRepositories		|| [ "${installedPpaRepositories["$name"]}" ];;
	build-dep:)	! getInstalledDebBuildDependencies	|| [ "${installedDebBuildDependencies["$name"]}" ];;
	deb+url:)	! getInstalledPackages			|| [ "${installedPackages["${name%%:*}"]}" ];;
	snap:)		! getInstalledSnapPackages		|| [ "${installedSnapPackages["$name"]}" ];;
	pip3:)		! getInstalledPip3Packages		|| [ "${installedPip3Packages["$name"]}" ];;
	npm:)		! getInstalledNpmPackages		|| [ "${installedNpmPackages["$name"]}" ];;
	custom:)	customCheck "$name";;
	*)		printf >&2 'ERROR: Invalid type: %s\n' "$prefix"; exit 3;;
    esac
}

askTo()
{
    memoizeDecision --memoize-group setup-software "$@"
}

typeset -a addedPackages=()
typeset -a addedPpaRepositories=()
typeset -a addedDebBuildDependencies=()
typeset -a addedDebUrlPackages=()
typeset -a addedSnapPackages=()
typeset -a addedPip3Packages=()
typeset -a addedNpmPackages=()
typeset -a addedCustomActions=()
isAvailable()
{
    local packageManager="${1:?}"; shift
    local packageManagerName="${1:-$packageManager}"; shift

    if [ "${installedPackages["$packageManager"]}" ] || [ "${addedPackages["$packageManager"]}" ] || exists "$packageManager"; then
	return
    fi

    if askTo --subject "$packageManagerName" --verb 'is not yet' --state installed --action 'install it'; then
	addedPackages+=("$packageManagerName")
    else
	return 1
    fi
}
addItems()
{
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%$name}"
	case "$prefix" in
	    '')		    addedPackages+=("$name");;
	    ppa:)	    addedPpaRepositories+=("$name");;
	    build-dep:)	    addedDebBuildDependencies+=("$name");;
	    deb+url:)	    addedDebUrlPackages+=("$name");;
	    snap:)	    isAvailable snap snapd && addedSnapPackages+=("$name");;
	    pip3:)	    isAvailable pip3 && addedPip3Packages+=("$name");;
	    npm:)	    isAvailable npm  && addedNpmPackages+=("$name");;
	    custom:)	    addedCustomActions+=("${name#*:}");;
	    *)		    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"; exit 3;;
	esac
    done
}


pkgInstall()
{
    [ ${#addedPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt install ${addedPackages[*]}")
}

ppaInstall()
{
    [ ${#addedPpaRepositories[@]} -gt 0 ] || return
    local repo; for repo in "${addedPpaRepositories[@]}"
    do
	toBeInstalledCommands+=("${SUDO}${SUDO:+ }add-apt-repository ppa:$repo")
    done
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt update")
}

debBuildDependencyInstall()
{
    [ ${#addedDebBuildDependencies[@]} -gt 0 ] || return

    local databaseUpdate; printf -v databaseUpdate %q "${scriptDir}/${scriptName}"
    local buildDep; for buildDep in "${addedDebBuildDependencies[@]}"
    do
	toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt-get build-dep $buildDep && $databaseUpdate --database debBuildDependencies --add $buildDep")
    done
}

debUrlInstall()
{
    [ ${#addedDebUrlPackages[@]} -gt 0 ] || return
    local debUrlRecord; for debUrlRecord in "${addedDebUrlPackages[@]}"
    do
	local packageUrl="${debUrlRecord#*:}"
	local packageNameAndGlob="${debUrlRecord%:$packageUrl}"
	local packageGlob="${packageNameAndGlob##*/}"
	local packageName="${packageNameAndGlob%$packageGlob}"
	packageName="${packageName%/}"

	# Note: No sudo here, as the downloading will happen as the current user
	# and only the installation itself will be done through sudo.
	toBeInstalledCommands+=("deb-download-installer${packageName:+ --application-name "'"}${packageName}${packageName:+"'"} --expression '$packageGlob' --url '$packageUrl'")
    done
}

snapInstall()
{
    [ ${#addedSnapPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }snap install ${addedSnapPackages[*]}")
}

pip3Install()
{
    [ ${#addedPip3Packages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }pip3 install ${addedPip3Packages[*]}")
}

npmInstall()
{
    [ ${#addedNpmPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }npm install --global ${addedNpmPackages[*]}")
}

customInstall()
{
    [ ${#addedCustomActions[@]} -gt 0 ] || return

    local customAction; for customAction in "${addedCustomActions[@]}"
    do
	local customActionWithoutSudo="${customAction#\$SUDO }"
	local sudoPrefix="${customAction%$customActionWithoutSudo}"

	if [ -x "${customActionsDirspec}/${customActionWithoutSudo}" ]; then
	    customActionWithoutSudo="${customActionsDirspec}/${customActionWithoutSudo}"
	fi
	toBeInstalledCommands+=("${sudoPrefix:+${SUDO}${SUDO:+ }}${customActionWithoutSudo}")
    done
}


typeset -a definitions=()
for definitionFile
do
    if [ -f "${definitionDirspec}/${definitionFile}" -a "${definitionFile:0:1}" != '.' ]; then
	definitionFilespec="${definitionDirspec}/${definitionFile}"
    elif [ -f "${definitionFile}" ]; then
	definitionFilespec="$definitionFile"
    else
	printf >&2 'ERROR: Definition "%s" does not exist.\n' "$definitionFile"
	exit 2
    fi

    readarray -O ${#definitions[@]} -t definitions < "$definitionFilespec"
done
[ ${#definitions[@]} -eq 0 ] && exit 1



for definition in "${definitions[@]}"
do
    [[ "$definition" =~ ^[[:space:]]*# ]] && continue
    items="${definition%%[	 ]#*}"
    comment="${definition#$items}"
    comment="${comment#[	 ]#}"
    comment="${comment##[	 ]}"
    set -- $items
    itemVerb=are; [ $# -eq 1 ] && itemVerb=is

    typeset -a missingItems=()
    for item
    do
	hasItem "$item" || missingItems+=("$item")
    done

    if [ ${#missingItems[@]} -eq 0 ]; then
	[ "$isVerbose" ] && printf >&2 'Already installed: %s\n' "$definition"
    else
	what=
	if [ $# -gt ${#missingItems[@]} ]; then
	    what="missing: ${missingItems[*]}"
	elif [ $# -gt 1 ]; then
	    what='all are missing'
	fi

	if askTo --subject "$items" --verb "${comment:+(}${comment}${comment:+) }$itemVerb not yet" --state "installed${what:+ (}${what}${what:+)}" --action 'install it'; then
	    addItems "${missingItems[@]}"
	fi
    fi
done



ppaInstall
pkgInstall
debBuildDependencyInstall
debUrlInstall
snapInstall
pip3Install
npmInstall
customInstall

[ ${#toBeInstalledCommands[@]} -gt 0 ] && \
    printf '%s\n' "${toBeInstalledCommands[@]}"
