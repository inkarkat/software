#!/bin/bash
shopt -qs extglob nullglob
case ",${TRACE:-}," in *,${BASH_SOURCE[0]##*/},*) [ -z "$BATS_TEST_NAME" ] || BASH_XTRACEFD=3; set -x;; esac

: ${SETUPSOFTWARE_GROUP_VALID_TIMESPAN:=1d}
: ${SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN:=1d}
readonly GROUPDIR_FILTER_FILENAME='.groupdir-filter'
readonly GROUPDIR_DESCRIPTION_FILENAME='.groupdir-description'

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
readonly projectDir="$(dirname -- "$scriptDir")"
baseDir="${projectDir}/etc"
typeDir="${projectDir}/lib/types"
readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"

: ${SUDO:=sudo --set-home}; [ $EUID -eq 0 ] && SUDO=''	# Use root's home; especially pip3 writes to ~/.cache/pip and complains if the files belong to another user.

printShortUsage()
{
    local commandLineOptionExtensions; [ ${#commandLineOptions[@]} -gt 0 ] && commandLineOptionExtensions="$(joinBy --prefix '[' --suffix ']' '] [' "${!commandLineOptions[@]}")"
    local commandLineParameterExtensions; [ ${#commandLineParameters[@]} -gt 0 ] && commandLineParameterExtensions="$(joinBy --prefix '[' --suffix ' ARG]' ' ARG] [' "${!commandLineParameters[@]}")"

    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '--clear-group-recall|--clear-definition-recall|--clear-selection-store [...] -?|-h|--help | -H|--config-help [TYPE]'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" "[--check|--dry-run] [-q|--quiet|--silence-no-definitions|-v|--verbose] [-f|--force] [-y|--yes|([-q|--quiet] --recall-current-only|--recall-only)] [-b|--batch] [-s|--select DEFINITION [-s ...]] [--base-dir BASE-DIR] [--name NAME]${commandLineOptionExtensions:+ }${commandLineOptionExtensions}${commandLineParameterExtensions:+ }${commandLineParameterExtensions} -a|--all|([-q|--quiet] --group-recall-current-only|--group-recall-only)|GROUP-NAME|GROUP-FILESPEC ..."
    echo
    echo
    printf 'Usage: %q %s | tee install-script.sh && sh install-script.sh\n' "$(basename "$1")" "..."
    printf 'Usage: %q %s\n' "$(basename "$1")" '... --print-types|-P|--print-definitions|-p|--print|-e|--execute|--rebuild-selection-store'
    echo
    echo 'Suggestions for automation in a script:'
    echo
    printf 'Usage: packageInstallCommandLine="$(%q %s)" && eval "$packageInstallCommandLine"\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s | runWithPrompt --exit-on-failure\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '--execute --yes --batch [--select DEFINITION] [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    echo 'Recursive use:'
    echo
    printf "custom:'& --check --yes [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)':'%q --yes\${isBatch:+ --batch}\${isQuiet:+ --quiet}\${isVerbose:+ --verbose} [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'" "$(basename "$1")"
    echo
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    local IFS=$'\n'
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Guided wizard to interactively choose / take (with -y|--yes) (from DEFINITION(s)
/ all / the passed GROUP(s)) and [print commands to] install those selected
software items (from various sources).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --config-help|-H [TYPE]
			Show details about the configuration syntax for all /
			for TYPE.
    --check		Just check whether any installation would happen;
			succeed if nothing is chosen / all is up-to-date, fail
			if some installation action would be required. Can be
			combined with --print-definitions, but not with --print.
    --dry-run		Like --check, but behave like usual (success means some
			installation action would be required; failure means
			not), and also print related messages; just omit the
			installation commands.
    --print-types	Just print the available types (in the order they will
			be executed).
    --print-definitions|-P
			Just print the definitions that have pending
			installations.
    --print|-p		Just print the installation commands to standard output;
			by default, the command will balk when output is to the
			terminal, as it is supposed to be captured and executed.
    --execute|-e	Directly execute the installation commands (as long as
			they succeed; like with set -e) instead of just printing
			them.
    --quiet|-q		Suppress any informational user messages except errors
			and the querying itself. If this is passed before
			--[group-]recall-only, those messages will be silenced
			as well.
    --silence-no-definitions
			Do not print the message that no definitions have been
			found.
    --verbose|-v	Also mention already installed definitions that are
			skipped.
    --force|-f		Assume that nothing is already installed / all checks
			fail and always execute all installation actions.
			Definition filters still apply. It's recommended to
			limit the scope to a single GROUP or even DEFINITION via
			--select.
    --yes|-y		Accept all definitions (that are not yet installed and
			have been chosen) without the usual interactive query.
    --recall-current-only
			Only reconsider those definitions that are not yet
			installed but had been persistently accepted beforehand,
			and are still within the validity period of the made
			decision (i.e. ${SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN}.
			Useful to rerun a setup to catch those definitions that
			failed to install the first time.
    --recall-only	Only reconsider those definitions that are not yet
			installed but had (at any previous time) been
			persistently accepted beforehand (even if that validity
			period has passed).
			Used by update-software to check for updates to those
			definitions that had been selected before.
    --batch|-b		Skip any interactive user confirmation for installation
			commands (e.g. by the package manager).
    --select|-s	DEFINITION
			Choose DEFINITION, which must exactly match the COMMENT
			in a definition if one exists or the exact list of ITEMs
			(with definitions broken over multiple lines already
			joined), instead of considering all from the passed
			GROUP(s).
    --base-dir BASE-DIR Consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR instead of
			using those bundled with this project.
    --add-base-dir BASE-DIR
			Also consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR (with
			higher preference than those bundled with this project).
    --name NAME		Use NAME for storing the user's choices.
    --all|-a		Consider definitions from all existing definition
			groups.
    --group-recall-current-only
			Only reconsider those definition groups that had been
			persistently accepted and are still within the validity
			period of the made decision (i.e. ${SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN} when executed
			with --all.
			Useful to rerun a setup to catch those definitions that
			failed to install the first time.
    --group-recall-only	Only reconsider those definition groups that had (at any
			previous time) been persistently accepted beforehand
			(even if that validity period has passed) when executed
			with --all.
			Used by update-software to check for updates to those
			definition groups that had been selected before.
    --clear-group-recall
			Forget any persisted definition group choices made in
			previous invocations, and re-query all existing groups
			again.
    --clear-definition-recall
			Forget any persisted definition choices made in previous
			invocations, and re-query all definitions again.
    --clear-selection-store
			Forget any persisted definition [group] selections. For
			updates to selections to work, the selection store then
			has to be rebuilt via --rebuild-selection-store.
    --rebuild-selection-store
			Record any already (fully) installed definition as
			selected, so that any updates to it will be considered
			by update-software. (Selected definition groups will be
			automatically updated on the next setup-software run.)
    GROUP-NAME		Consider definitions from GROUP-NAME, as stored inside
			this project / BASE-DIR.
    GROUP-FILESPEC	Consider definitions from GROUP-FILESPEC, which can
			point to anywhere in the file system.
${commandLineHelpExtensions[*]}
EXIT STATUS:
    0	Complete success.
    1	Failed to install (especially failure in pre- or postinstall actions).
    2	Bad invocation, wrong or missing command-line arguments.
    3	Invalid definition syntax, internal error or failed assertion.
    4	All definition(s) [groups] were declined or already installed.
    99	No definitions have been found.
HELPTEXT
}


getTypePrefixesInTypeOrder()
{
    typeset -a typeOrdering=("${!typeInstallOrder[@]}")
    readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

    typeset -a typeOrdering=("${!typeInstallOrder[@]}")
    readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

    typeset -A mirroredTypeRegistry=()
    for prefix in "${!typeRegistry[@]}"
    do
	mirroredTypeRegistry["${typeRegistry["$prefix"]}"]="$prefix"
    done

    typeset -a prefixes=()
    local order; for order in "${typeOrdering[@]}"
    do
	printf '%s\n' "${mirroredTypeRegistry["${typeInstallOrder["$order"]}"]}"
    done
}

highlightPrefix()
{
    local sedPrefixHighlighting; [ ${#pager[@]} -gt 0 ] && sedPrefixHighlighting='1s/^\([^:]\+:\)/[01m&[0m/'
    sed -e "$sedPrefixHighlighting"
}
printConfigUsageForTypes()
{
    local padding=
    local prefix; for prefix
    do
	local typeName="${typeRegistry["${prefix:-native}:"]}"
	local definitionFilterFunction="${definitionFilterTypeRegistry["${prefix}:"]}"
	local definitionGroupFilterFunction="${definitionGroupFilterTypeRegistry["${prefix}:"]}"
	if [ -n "$typeName" ]; then
	    printf "$padding"
	    "configUsage${typeName}" | highlightPrefix
	elif [ -n "$definitionFilterFunction" ]; then
	    printf "$padding"
	    "configUsage${definitionFilterFunction}" | highlightPrefix
	elif [ -n "$definitionGroupFilterFunction" ]; then
	    printf "$padding"
	    "configUsage${definitionGroupFilterFunction}" | highlightPrefix
	elif [ "$prefix" = var ]; then
	    printf "$padding"
	    configUsageVar | highlightPrefix
	elif [ "$prefix" = config ]; then
	    printf "$padding"
	    configUsageConfig | highlightPrefix
	elif [ "$prefix" = decorate ]; then
	    printf "$padding"
	    configUsageDecorate | highlightPrefix
	elif [ "$prefix" = preinstall ]; then
	    printf "$padding"
	    configUsagePreinstall | highlightPrefix
	elif [ "$prefix" = pre-all-install ]; then
	    printf "$padding"
	    configUsagePreAllInstall | highlightPrefix
	elif [ "$prefix" = postinstall ]; then
	    printf "$padding"
	    configUsagePostinstall | highlightPrefix
	elif [ "$prefix" = post-all-install ]; then
	    printf "$padding"
	    configUsagePostAllInstall | highlightPrefix
	elif [ "$prefix" = postinstall-or-once ]; then
	    printf "$padding"
	    configUsagePostinstallOrOnce | highlightPrefix
	elif [ "$prefix" = post-all-install-or-once ]; then
	    printf "$padding"
	    configUsagePostAllInstallOrOnce | highlightPrefix
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	padding=$'\n'
    done
}
printConfigUsage()
{
    if [ $# -eq 0 ]; then
	cat <<HELPTEXT
A definition consists of one or many whitespace-separated ITEMs, optionally
followed by a # DESCRIPTION. It can be broken over multiple lines, with a
trailing \\ as the line continuation character. Each ITEM may have implicit pre-
and post-install steps in ./etc/{pre,post}install/ITEM/*, allowing for
customization around their installation no matter in which definition ITEM has
been selected.
Definitions are grouped into DEFINITION-GROUPs which contain definitions that
belong to a certain category or are typically installed together for a certain
use case.
Definition groups can be excluded from consideration, either completely or
starting from a certain line, through definition group filters. These work like
definition filters, but the entire definition has to consist of them (no mixing
with other items).
Multiple definition group filters within one line are OR-ed together; if at
least one passes, reading of definitions continues. To require the passing of
all definition group filters (logical AND), put them on subsequent lines.
If a complete definition group is excluded, it won't be offered by --all,
neither. To exclude a complete subdirectory of definition groups, you can put a
DEFINITION-GROUP-DIR/${GROUPDIR_FILTER_FILENAME} file in there; it has to start
with the definition group filter(s) and then must be followed by a regular dummy
definition (e.g. simply a line containing "dummy:"). If it is completely empty,
the whole subdirectory will be filtered unconditionally.
HELPTEXT
	echo
	typeset -a prefixes=()
	readarray -t prefixes < <(getTypePrefixesInTypeOrder)
	typeset -a definitionFilterPrefixes=("${!definitionFilterTypeRegistry[@]}")
	typeset -a definitionGroupFilterPrefixes=("${!definitionGroupFilterTypeRegistry[@]}")

	printConfigUsageForTypes "${prefixes[@]%:}" "${definitionFilterPrefixes[@]%:}" "${definitionGroupFilterPrefixes[@]%:}"    # Show config help for all types (in the order in which the types are also installed).

	echo
	configUsageVar | highlightPrefix
	echo
	configUsageConfig | highlightPrefix
	echo
	configUsageDecorate | highlightPrefix
	echo
	configUsagePreinstall | highlightPrefix
	echo
	configUsagePostinstall | highlightPrefix
	echo
	configUsagePostinstallOrOnce | highlightPrefix
    else
	printConfigUsageForTypes "$@"
    fi
}

# Make this available already before sourcing the type libraries so that types
# can use it for a guard whether the base application is installed
# (e.g. if ! exists firefox || ! hasNative firefox; then ...)

typeset -a commandLineHelpExtensions=()
typeset -A commandLineOptions=()
typeset -A commandLineParameters=()

typeset -a nativeRegistry=()
typeset -A typeRegistry=()
typeset -A definitionFilterTypeRegistry=()
typeset -A definitionGroupFilterTypeRegistry=()

hasNative()
{
    [ ${#nativeRegistry[@]} -gt 0 ] && has${nativePackageManager:?} "$@"
}
addNative()
{
    add${nativePackageManager:?} "$@"
}

messagePrintf()
{
    [ "$isQuiet" ] && return
    printf >&2 "$@"
}

silentRecallDecision()
{
    recallDecision >/dev/null 2>&1 "$@"
}


selectedDefinitionDatabase()
{
    keyDatabase "selectedDefinitions${setupAppendix:+-}${setupAppendix}" --namespace "$setupName" "$@"
}
selectedDefinitionGroupDatabase()
{
    keyDatabase "selectedDefinitionGroups${setupAppendix:+-}${setupAppendix}" --namespace "$setupName" "$@"
}

storeSelectedDefinition()
{
    local subject="${1:?}"; shift
    selectedDefinitionDatabase --add "$subject"
}
storeSelectedDefinitionGroup()
{
    local subject="${1:?}"; shift
    selectedDefinitionGroupDatabase --add "$subject"
}

hasDefinitionBeenSelected()
{
    local subject="${1:?}"; shift
    selectedDefinitionDatabase --query "$subject"
}
hasDefinitionGroupBeenSelected()
{
    local subject="${1:?}"; shift
    selectedDefinitionGroupDatabase --query "$subject"
}


getSubjectFromItems()
{
    typeset -a typeItems=()
    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	[ -n "${typeRegistry["${prefix:-native:}"]}" ] && \
	    typeItems+=("$item")
    done
    [ ${#typeItems[@]} -eq 0 ] && typeItems=("$@")

    joinBy ' ' "${typeItems[@]}"
}

getDefinitionGroupFilespec()
{
    local definitionGroup="${1:?}"; shift
    local dirspec; for dirspec in "${definitionDirspecs[@]}"
    do
	local definitionGroupFilespec="${dirspec}/${definitionGroup}"
	if [ -f "$definitionGroupFilespec" ]; then
	    printf %s "$definitionGroupFilespec"
	    return 0
	fi
    done
    return 1
}

parseDefinitionGroup()
{
    local definitionGroupFilespec="${1:?}"; shift
    let physicalLineCnt=0
    exec 3<&0
    while IFS=$'\n' read -r line
    do
	let physicalLineCnt+=1
	while [[ "$line" =~ \\$ ]]
	do
	    let physicalLineCnt+=1
	    IFS=$'\n' read -r nextLine
	    line="${line%\\}$nextLine"
	done
	[[ "$line" =~ ^[[:space:]]*# ]] && continue
	[[ "$line" =~ ^[[:space:]]*$ ]] && continue

	testDefinitionGroupFilter "$line" <&3
	case $? in
	    1)	continue;;	# This is a definition group filter, but it did not filter.
	    2)	exec 0<&3; return;;	# The filter applies; skip the entire remainder of the definition group file.
	esac

	if [ ${#selections[@]} -eq 0 ]; then
	    definitions+=("$line")
	else
	    items="${line%%[	 ]#*}"
	    comment="${line#"$items"}"
	    comment="${comment##+([	 ])#*([	 ])}"
	    if [ -n "$comment" ]; then
		subject="$comment"  # Note: Do not eval the comment here, as that would make it much harder to exactly match the selection.
	    else
		eval "set -- $items"
		subject="$(getSubjectFromItems "$@")"
	    fi

	    contains "$subject" "${selections[@]}" && \
		definitions+=("$line")
	fi
    done < "$definitionGroupFilespec"
    exec 0<&3
}

testDefinitionGroupFilter()
{
    local line="$1"; shift
    eval "set -- ${line%%[	 ]#*}"
    local lastDefinitionGroupFilterItem= item
    for item
    do
	local filter="${item#*:}"
	local prefix="${item%"$filter"}"
	if contains "$prefix" "${!definitionGroupFilterTypeRegistry[@]}"; then
	    lastDefinitionGroupFilterItem="$item"
	    local definitionGroupFilterFunction="${definitionGroupFilterTypeRegistry["$prefix"]}"
	    if [ -n "$definitionGroupFilterFunction" ]; then
		"isDefinitionGroupAcceptedBy${definitionGroupFilterFunction}" "$filter" "group $definitionGroup, after line $physicalLineCnt" && \
		    return 1	# (At least) one definition group filter in this line passes.
	    fi
	elif [ -n "$lastDefinitionGroupFilterItem" ]; then
	    printf >&2 'ERROR: Definition group filter types (%s) must not be mixed with other items (%s) in a single definition.\n' "$lastDefinitionGroupFilterItem" "$item"
	    exit 3
	else
	    return 0	# If the first item isn't a definition group filter, the other's cannot be such, neither. We'll catch any in the later processing stages.
	fi
    done
    [ -z "$lastDefinitionGroupFilterItem" ] || return 2	# None of the definition group filters passed; skip the entire definition group file.
}

isDefinitionGroupCompletelyFiltered()
{
    local definitionGroup="${1:?}"; shift
    local definitionGroupFilespec; definitionGroupFilespec="$(getDefinitionGroupFilespec "$definitionGroup")" || return 1

    typeset -a definitions=()
    parseDefinitionGroup "$definitionGroupFilespec"
    [ ${#definitions[@]} -eq 0 ]
}

isDefinitionGroupDir()
{
    local group="${1:?}"; shift
    local dirspec; for dirspec in "${definitionDirspecs[@]}"
    do
	[ -d "${dirspec}/${group}" ] && return 0
    done
    return 1
}
typeset -a acceptedGroups=()
addAllAcceptedGroups()
{
    typeset -a groups=()
    readarray -t groups < <(for dirspec in "${definitionDirspecs[@]}"
	do
	    cd "$dirspec" && find . -not -path '*/\.*' -printf '%P\n'
	done | sort --ignore-case
    )
    typeset -a filteredGroups=()
    typeset -a withHeaderFirstArg=(--first)
    local group; for group in "${groups[@]}"
    do
	: ${group:=.}
	contains "$group" "${filteredGroups[@]}" && continue

	local groupSubject="${group##+([0-9])}"	# Leading digits are used for ordering; drop them for querying the user and recalling as they are irrelevant to them and may be subject to change.
	local setupAppendix=''	# This may be modified by definition group filters (through isDefinitionGroupCompletelyFiltered()); reset it on every iteration here.
	if isDefinitionGroupDir "$group"; then
	    groupDirectoryGroupCount=$(countGlob "${group}/*" "${groups[@]}")
	    ! isDefinitionGroupCompletelyFiltered "${group}/${GROUPDIR_FILTER_FILENAME}" \
		&& if [ $groupDirectoryGroupCount -gt 1 ]; then
		    local groupDirDescriptionFilespec="$(getDefinitionGroupFilespec "${group}/${GROUPDIR_DESCRIPTION_FILENAME}")"
		    if [ "$isPrintGroups" ] && [ -r "$groupDirDescriptionFilespec" ]; then
			cat -- "$groupDirDescriptionFilespec" \
			    | withHeader "${withHeaderFirstArg[@]}" --no-newline -- "$groupSubject" \
				>&2
		    fi

		    # Ignore a group directory that has only one group in it; the query for the group itself will suffice.
		    withHeaderFirstArg=()
		    askGroup "$groupSubject" --verb "directory (with $groupDirectoryGroupCount groups) is not" --state 'chosen' --action 'consider it'
		fi \
		|| readarray -O ${#filteredGroups[@]} -t filteredGroups < <(filterGlob "${group}/*" "${groups[@]}")
	    continue
	fi

	isDefinitionGroupCompletelyFiltered "$group" && continue

	[ ! "$isPrintGroups" ] ||
	    printSpecialComments -- "$(getDefinitionGroupFilespec "$group")" \
		| withHeader "${withHeaderFirstArg[@]}" --no-newline -- "$groupSubject" \
		    >&2

	withHeaderFirstArg=()
	askGroup "$groupSubject" --verb 'is not' --state 'chosen' --action 'consider it' \
	    && acceptedGroups+=("$group")
    done
}

typeset -A variables=()
cleanVariables()
{
    local variableName; for variableName in "${!variables[@]}"
    do
	eval "${variables["$variableName"]}"
    done
}

let definitionCnt=0
parseDefinitionGroups()
{
    typeset -a definitions=()
    local definitionGroup definitionGroupFilespec
    for definitionGroup
    do
	if [ "${definitionGroup:0:1}" != '.' ] && definitionGroupFilespec="$(getDefinitionGroupFilespec "$definitionGroup")"; then
	    :
	elif [ -f "${definitionGroup}" ]; then
	    definitionGroupFilespec="$definitionGroup"
	else
	    printf >&2 'ERROR: Definition "%s" does not exist.\n' "$definitionGroup"
	    exit 2
	fi

	parseDefinitionGroup "$definitionGroupFilespec"
    done
    if [ ${#definitions[@]} -eq 0 ]; then
	[ "$isSilenceNoDefinitions" ] || messagePrintf '%s\n' 'No definitions have been found.'
	return 99
    fi


    local definition items comment subject
    for definition in "${definitions[@]}"
    do
	let definitionCnt+=1
	cleanVariables

	items="${definition%%[	 ]#*}"
	comment="${definition#"$items"}"
	comment="${comment#[	 ]#}"
	comment="${comment##[	 ]}"

	# Revert to the normal shell globbing behavior when parsing the items from a
	# definition; we want stuff like $(lastFiles foo/*) to work properly and keep
	# globs in deb+url:discord:1mo:collaboration/Discord/discord-*.deb:'https://discordapp.com/api/download?platform=linux&format=deb'
	# as well.
	set +o noglob; shopt -qu nullglob
	    eval "set -- $items"
	set -o noglob; shopt -qs nullglob

	setupAppendix=''	# This may be modified by definition filters (through isDefinitionAcceptedBy${definitionFilterFunction}()); reset it for every definition here.
	local item name prefix definitionFilterFunction
	for item
	do
	    name="${item#*:}"
	    prefix="${item%"$name"}"
	    if [ -z "$prefix" ]; then
		:
	    elif [ "$prefix" = var: ]; then
		if [[ ! "$name" =~ ^([a-zA-Z_][a-zA-Z0-9_]*)=(.*)$ ]]; then
		    printf >&2 'ERROR: Invalid variable definition: %s.\n' "$item"
		    exit 3
		fi
		local variableName=${BASH_REMATCH[1]}
		local variableValue=${BASH_REMATCH[2]}
		local -n variable=$variableName
		if ! contains "$variableName" "${!variables[@]}"; then
		    if eval "[ -n \"\${${variableName}+t}\" ]"; then
			printf -v quotedVariable '%q' "$variable"
			variables["$variableName"]="$variableName=$quotedVariable"
		    else
			variables["$variableName"]="unset $variableName"
		    fi
		fi
		export variable="$variableValue"
	    else
		definitionFilterFunction="${definitionFilterTypeRegistry["$prefix"]}"
		if [ -n "$definitionFilterFunction" ]; then
		    "isDefinitionAcceptedBy${definitionFilterFunction}" "$name" "$definition" || \
			continue 2
		fi
	    fi
	done
	if [ ${#variables[@]} -gt 0 ]; then
	    # Need to re-parse the items so that the variables are expanded.
	    set +o noglob; shopt -qu nullglob
		eval "set -- $items"
	    set -o noglob; shopt -qs nullglob

	    # Remove the leading variable definitions.
	    while [ $# -gt 0 ] && [[ "$1" =~ ^var: ]]
	    do
		shift
	    done
	fi

	if [ -n "$comment" ]; then
	    subject="$(printf %s "$comment" | evalFile)"
	else
	    subject="$(getSubjectFromItems "$@")"
	fi
	let handledDefinitionCount+=1
	typeset -a missingItems=()
	typeset -a missingItemConfigurations=()
	local lastRealItem=
	typeset -a lastConfigurations=()
	local lastDecoration=
	local lastMissingItem=
	let realItemCnt=0
	let missingRealItemCnt=0
	local noMissingItemMessage="Already installed: $subject"
	for item
	do
	    name="${item#*:}"
	    prefix="${item%"$name"}"
	    if contains "$prefix" "${!definitionFilterTypeRegistry[@]}"; then
		continue    # Ignore; definition filters have already been handled.
	    elif contains "$prefix" "${!definitionGroupFilterTypeRegistry[@]}"; then
		printf >&2 'ERROR: Definition group filter types (like %s) must only appear the beginning of a definition group: %s.\n' "$prefix" "$item"
		exit 3
	    elif contains "$prefix" preinstall: pre-all-install: postinstall: post-all-install:; then
		if [ -z "$lastRealItem" ]; then
		    printf >&2 'ERROR: No previous item before %s.\n' "$item"
		    exit 3
		elif [ "$lastRealItem" = "$lastMissingItem" ]; then
		    # The preinstall action will run when the previous item will
		    # be installed. The postinstall action will run when the
		    # installation of the previous item was successful. To be
		    # able to check that, we need that item as well, so append
		    # it on a new line.
		    missingItems+=("$item"$'\n'"$lastMissingItem")
		fi
	    elif [ "$prefix" = var: ]; then
		printf >&2 'ERROR: Variables must only appear at the beginning of a definition: %s is not at the beginning of %s\n' "$item" "$definition"
		exit 3
	    elif [ "$prefix" = config: ]; then
		# The configuration still needs the following real item to be
		# complete; all we can do right now is storing the configuration
		# itself.
		lastConfigurations+=("$item")
		continue
	    elif [ "$prefix" = decorate: ]; then
		lastDecoration="$item"
		continue
	    elif [ "$prefix" = postinstall-or-once: ] || [ "$prefix" = post-all-install-or-once: ]; then
		if [ -z "$lastRealItem" ]; then
		    printf >&2 'ERROR: No previous item before %s.\n' "$item"
		    exit 3
		else
		    [ ! "$isForce" ] && hasItem "$lastRealItem"
		    case $? in
			0)	rest="${name#*:}"
				id="${name%"$rest"}"
				if [ -n "$id" ] && [ -n "${typeRegistry["$id"]}" ]; then
				    # Don't take an existing type prefix as the optional ID.
				    id="$name"; rest="$name"
				else
				    id="${id%:}"
				fi
				id="${id:-$rest}"
				escapedId="${id//	/ }"
				onceMarker --query "$escapedId"
				case $? in
				    0)	;;  # The item already is installed, and the check has been run already.
				    1|4)
					# The item already is installed, but the check did not run yet.
					if [ "$prefix" = postinstall-or-once: ]; then
					    addPostinstall "$rest"$'\n'"$lastRealItem" --post-or-once --id "$escapedId"
					elif [ "$prefix" = post-all-install-or-once: ]; then
					    addPreOrPostinstall post-all "$rest"$'\n'"$lastRealItem" --post-or-once --id "$escapedId"
					else
					    printf >&2 'ASSERT: Unexpected prefix: %s\n' "$prefix"; exit 3
					fi
					noMissingItemMessage="Only postinstall required for $subject"
					;;
				    *)	exit 3;;
				esac
				;;
			98)	;;
			99)	;;
			*)	if [ -n "$lastMissingItem" ]; then
				    # The postinstall action will run when the installation of the
				    # previous item was successful. To be able to check that, we
				    # need that item as well, so append it on a new line.
				    missingItems+=("${prefix%-or-once:}:${name}"$'\n'"$lastMissingItem")
				fi
				;;
		    esac
		fi
	    elif [ "$prefix" = dummy: ]; then
		# Don't do decorations on dummy items.

		# Treat dummy items as real items, so that we can do pre- and
		# postinstall actions on them.
		lastRealItem="$item"
		[ ! "$isForce" ] && hasItem "$item"
		case $? in
		    0)  lastMissingItem=;;
		    98) # Just skip this item.
			noMissingItemMessage="Just skipped items in $subject"
			continue
			;;
		    99) # If one item's state cannot not be determined, the entire definition should be skipped, as we cannot ensure the correct installation.
			noMissingItemMessage="Skipped: $subject"
			let handledDefinitionCount-=1
			break
			;;
		    *)  # Add missing dummy items to missingItemConfigurations instead of missingItems, so that a definition with just missing dummy items does not query the user, but if there are other missing items, the dummy one will be included, too.
			#missingItems+=("$item")
			missingItemConfigurations+=("$item")
			lastMissingItem="$item"
			let missingRealItemCnt+=1

			# Don't do configurations on dummy items.
			;;
		esac
	    else
		if [ -n "$lastDecoration" ]; then
		    addDecorate "${lastDecoration#decorate:}"$'\n'"$item"
		    lastDecoration=''
		fi

		lastRealItem="$item"

		hasConfiguration=()   # Clear the potential configurations for each item, to avoid that configs from a previous item affect following ones.
		local c
		for c in "${lastConfigurations[@]}"
		do
		    hasConfig "${c#*:}"$'\n'"$item"
		done

		[ ! "$isForce" ] && hasItem "$item"
		case $? in
		    0)  lastMissingItem=;;
		    98) # Just skip this item. This is useful for supplementary item types like Apt repos and keys (where the actual Apt package might still be installable).
			noMissingItemMessage="Just skipped items in $subject"
			continue
			;;
		    99) # If one item's state cannot not be determined, the entire definition should be skipped, as we cannot ensure the correct installation.
			noMissingItemMessage="Skipped: $subject"
			let handledDefinitionCount-=1
			break
			;;
		    *)  missingItems+=("$item")
			lastMissingItem="$item"
			let missingRealItemCnt+=1

			# With the real item, we can finally assemble the complete
			# configurations for it. Collect them in a separate array
			# because
			# a) we don't want them counted (like decorations, these are
			#    just meta-information)
			# b) these need to be added first, so that the add*()
			#    function can already access the configuration
			for c in "${lastConfigurations[@]}"
			do
			    missingItemConfigurations+=("$c"$'\n'"$item")
			done
			;;
		esac
		let realItemCnt+=1
		lastConfigurations=()
	    fi
	done

	if [ ${#missingItems[@]} -eq 0 ]; then
	    [ "$isRebuildSelectionStore" ] && storeSelectedDefinition "$subject"
	    [ "$isVerbose" ] && messagePrintf '%s\n' "$noMissingItemMessage"
	else
	    let missingDefinitionCount+=1
	    local what=
	    local itemVerb=are; [ -n "$comment" -o $realItemCnt -eq 1 ] && itemVerb=is
	    local itemAuxVerb=
	    if [ $realItemCnt -gt $missingRealItemCnt ]; then
		missingItemsPlural=s; [ $missingRealItemCnt -eq 1 ] && missingItemsPlural=
		what="$missingRealItemCnt item${missingItemsPlural} missing: ${missingItems[*]}"
	    elif [ $realItemCnt -gt 1 ]; then
		what="all $missingRealItemCnt items are missing"
	    fi

	    if [ $missingRealItemCnt -eq 1 ] && [[ "${missingItems[0]}" =~ 'custom:once:' ]]; then
		itemVerb='may or may'
		itemAuxVerb=be
	    fi

	    if askTo "$subject" --verb "$itemVerb not yet${itemAuxVerb:+ }$itemAuxVerb" --state "installed${what:+ (}${what}${what:+)}" --action 'install it'; then
		let addedDefinitionCount+=1
		# Add the configurations first, so that they are available to the
		# add*() function for the real item already.
		addItems "${missingItemConfigurations[@]}" "${missingItems[@]}" \
		    || messagePrintf 'ERROR: Failed to add missing items in %s.\n' "$subject"

		[ ! "$isPrintDefinitions" ] || printf '%s\n' "$subject"
	    fi
	fi
    done
    cleanVariables
    return 0
}


keyDatabase()
{
    # Note: No --namespace "$setupName" here, because the information usually is
    # system scoped (e.g. for the build-dep type). If clients want this scoped
    # to the setup, they can pass the arguments themselves.
    picoDB --base-type data --table "$@"
}
keyValueDatabase()
{
    # Note: No --namespace "$setupName" here, because the information usually is
    # system scoped. If clients want this scoped to the setup, they can pass the
    # arguments themselves.
    miniDB --base-type data --table "$@"
}

onceMarker()
{
    executionMarker --base-type data --namespace "$setupName" --group postinstall-or-once "$@"
}

createSetupName()
{
    setupName="$(basename -- "$(dirname -- "$(simplifyPath "${1:?}")")")"
    setupName="setup-${setupName#setup-}"
}

configUsageNative()
{
    # Note: Do not delegate to configUsage$nativePackageManager().
    cat <<HELPTEXT
Items without a prefix refer to packages installed via the distribution's
package manager (${nativePackageManager,}).
HELPTEXT
}
configUsageVar()
{
    cat <<'HELPTEXT'
var: meta items define shell variables that can be referenced in the remainder
of the current definition (just like regular environment variables), e.g. to
avoid duplication in the definition. The format is
    VARIABLE=VALUE
They must appear before any other item and cannot themselves refer to previously
defined variables. They go out of scope after the current definition; any
existing environment variable value is restored.
HELPTEXT
}
configUsageConfig()
{
    cat <<'HELPTEXT'
config: meta items supply special (type-specific) configuration to the non-meta
non-pre/postinstall item following it in the current definition if that item is
missing, but has now been selected. The configuration is available to has*(),
add*() and install() functions. If there are multiple configurations for an
item, they are concatenated, separated by a newline. The format itself is
undefined, but needs to be a single line, and often is in the form
VARIABLE=VALUE, so that it can simply be eval'd by the type.
HELPTEXT
}
configUsageDecorate()
{
    cat <<'HELPTEXT'
decorate: meta items either prepend CMD-PREFIX to or replace all occurrences of
{} in CMD-DECORATION with the quoted installation command (and possibly a check
command as well if the type has such) of the non-meta non-pre/postinstall item
following it in the current definition if that item is missing, but has now been
selected.
The same item (if it appears multiple times) must be decorated consistently, or
individual items may go undecorated; a mixture of decorations is not supported.
Types that process multiple items with a single install command may not accept
decorations, or a single decoration that then applies to the whole set of items,
or may split off decorated items into separate install commands.
HELPTEXT
}

configUsagePrePostInstall()
{
    local typeName="${1:?}"; shift
    local what="${1:?}"; shift
    [[ "$typeName" = *-or-once ]] \
	&& local action='[ID:]ACTION where the latter' \
	|| local action='an ACTION that'
    cat <<HELPTEXT
${typeName}: items consist of ${action} is one of the following:
- an EXECUTABLE-COMMAND (potentially followed by command-line arguments) in the
  ./etc/${what} directory tree that is invoked (prepend \$SUDO if it needs to
  be invoked as root) and should then perform the ${what}ation steps
- a TEXT-FILE in the ./etc/${what} directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual pre-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a ${what^^}-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend \$SUDO if it needs to be invoked as root)
HELPTEXT
}
configUsagePreinstall()
{
    configUsagePrePostInstall preinstall preinstall
    cat <<'HELPTEXT'
A preinstall item runs (just before the item type's installation actions) if the
non-meta non-pre/postinstall item preceding it in the current definition is
missing, but has now been selected.
HELPTEXT
}
configUsagePreAllInstall()
{
    configUsagePrePostInstall pre-all-install preinstall
    cat <<'HELPTEXT'
A pre-all-install item runs (before all installation actions) if the non-meta
non-pre/postinstall item preceding it in the current definition is missing, but
has now been selected.
HELPTEXT
}
configUsagePostinstall()
{
    configUsagePrePostInstall postinstall postinstall
    cat <<'HELPTEXT'
A postinstall item runs (just after the item type's installation actions) if the
non-meta non-pre/postinstall item preceding it in the current definition was
missing, but has been successfully installed by the installation commands.
HELPTEXT
}
configUsagePostAllInstall()
{
    configUsagePrePostInstall post-all-install postinstall
    cat <<'HELPTEXT'
A post-all-install item runs (after all installation actions) if the non-meta
non-pre/postinstall item preceding it in the current definition was missing, but
has been successfully installed by the installation commands.
HELPTEXT
}
configUsagePostinstallOrOnce()
{
    configUsagePrePostInstall postinstall-or-once postinstall
    cat <<'HELPTEXT'
Like a postinstall item, a postinstall-or-once item runs if the
non-meta non-pre/postinstall item preceding it in the current definition was
missing, but has been successfully installed by the installation commands.
Additionally, if the non-meta non-pre/postinstall item preceding it already
existed (e.g. it comes preinstalled), it will also run once (until it succeeds);
ID or ACTION itself is used for that uniqueness check.
HELPTEXT
}
configUsagePostAllInstallOrOnce()
{
    configUsagePrePostInstall post-all-install-or-once postinstall
    cat <<'HELPTEXT'
Like a post-all-install item, a post-all-install-or-once item runs if the
non-meta non-pre/postinstall item preceding it in the current definition was
missing, but has been successfully installed by the installation commands.
Additionally, if the non-meta non-pre/postinstall item preceding it already
existed (e.g. it comes preinstalled), it will also run once (until it succeeds);
ID or ACTION itself is used for that uniqueness check.
HELPTEXT
}

typeset -A hasConfiguration=()
hasConfig()
{
    local valueAndItem="${1:?}"; shift
    local item="${valueAndItem#*$'\n'}"
    # Convert the "VALUE\nITEM" to hasConfiguration[ITEM]=VALUE.
    # This can be queried by the has${typeName}() function to affect the
    # check command already. This is a separate dict to avoid interference with
    # added items.
    local newValue="${valueAndItem%%$'\n'*}"
    local existingValue="${hasConfiguration["$item"]}"
    hasConfiguration["$item"]="${existingValue}${existingValue:+$'\n'}${newValue}"
}
typeset -A configuration=()
addConfig()
{
    local valueAndItem="${1:?}"; shift
    local item="${valueAndItem#*$'\n'}"
    # Convert the "VALUE\nITEM" to configuration[ITEM]=VALUE.
    # This can be queried by add${typeName}() and install${typeName}(),
    # and usually affects the rendering of the install command.
    local newValue="${valueAndItem%%$'\n'*}"
    local existingValue="${configuration["$item"]}"
    configuration["$item"]="${existingValue}${existingValue:+$'\n'}${newValue}"
}

typeset -A decoration=()
addDecorate()
{
    local valueAndItem="${1:?}"; shift
    local item="${valueAndItem#*$'\n'}"
    # Convert the "VALUE\nITEM" to decoration[ITEM]=VALUE.
    # This can be queried by install${typeName}() and considered when
    # rendering the install command.
    local newValue="${valueAndItem%%$'\n'*}"
    local existingValue="${decoration["$item"]}"
    if [ -n "$existingValue" -a "$existingValue" != "$newValue" ]; then
	printf >&2 'ERROR: Differing decoration "%s" and "%s" for %s\n' "$existingValue" "$newValue" "$item"
	exit 3
    fi
    decoration["$item"]="$newValue"
}
decorateCommand()
{
    local installCommand="${1:?}"; shift
    local decoration="$1"; shift

    if [[ "$decoration" =~ \{\} ]]; then
	printf -v quotedInstallCommand '%q' "$installCommand"
	printf %s "${decoration//\{\}/"$quotedInstallCommand"}"
    elif [ -n "$decoration" ]; then
	printf %s "${decoration}${decoration:+ }$installCommand"
    else
	printf %s "$installCommand"
    fi
}
submitInstallCommand()
{
    toBeInstalledCommands+=("$(decorateCommand "$@")")
}

addPreOrPostinstall()
{
    local when="${1:?}"; shift
    local valueAndItem="${1:?}"; shift
    local recursiveCallArg="$1"; shift

    # Convert the "ACTION\nITEM" to --post ITEM --action ACTION.
    local item="${valueAndItem#*$'\n'}"
    local action="${valueAndItem%%$'\n'*}"
    local name="${item#*:}"
    local prefix="${item%"$name"}"
    if [[ "$when" = *-all ]]; then
	when="${when%-all}"
	local typeName=''
    else
	local typeName="${typeRegistry["${prefix:-native:}"]}"
    fi
    eval "added${when^}installArgs${typeName}+=(\"\${recursiveCallArg:---${when}}\" \"\$item\" --action \"\$action\" \"\$@\")"
}

addPreinstall()
{
    addPreOrPostinstall pre "$@"
}
preinstallHook()
{
    local typeName="${1:?}"; shift
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && eval "addedPreinstallArgs${typeName}"+='(--pre "$name" --action "${actionScript#"${dirspec}/"}")'
	    done
	done
    set -o noglob
}
addPostinstall()
{
    addPreOrPostinstall post "$@"
}
addPostinstallContextCommand()
{
    local typeName="${1:?}"; shift
    [ $# -gt 0 ] || exit 3
    printf -v quotedContextCommand '%q ' "$@"; quotedContextCommand="${quotedContextCommand% }"
    eval "addedPostinstallContextArgs${typeName}"+='(--post-context "$quotedContextCommand")'
}
postinstallHook()
{
    local typeName="${1:?}"; shift
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && eval "addedPostinstallArgs${typeName}"+='(--post "$name" --action "${actionScript#"${dirspec}/"}")'
	    done
	done
    set -o noglob
}

invokeCheck()
{
    invocationMessage --or-passthrough --clear all --message "Checking${subject:+ }${subject}... " --initial-delay 500ms --spinner --render-timer 1s --command "${1:?}"
}

hasItem()
{
    local item="${1:?}"; shift
    local name="${item#*:}"
    local prefix="${item%"$name"}"

    local typeName="${typeRegistry["${prefix:-native:}"]}"
    if [ -n "$typeName" ]; then
	"has${typeName}" "$name"
    else
	printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	exit 3
    fi
}

typeset -A cachedDecisions=()
memoizeAndCacheDecision()
{
    local subject
    typeset -a memoizeDecisionArgs=()
    while [ $# -ne 0 ]
    do
	case "$1" in
	    --help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	    --subject|-s)	memoizeDecisionArgs+=("$1" "$2"); subject="$2"; shift; shift;;
	    --)			memoizeDecisionArgs+=("$1"); shift; break;;
	    *)			memoizeDecisionArgs+=("$1"); shift;;
	esac
    done

    [ -n "${cachedDecisions["$subject"]}" ] && \
	return ${cachedDecisions["$subject"]}

    memoizeDecision "${memoizeDecisionArgs[@]}" "$@"; local status=$?
    cachedDecisions["$subject"]=$status
    return $status
}

askGroup()
{
    local groupSubject="${1:?}"	# Don't shift off
    if $obtainPastGroupSelection "$groupSubject"; then
	# The stored selected definition overrules any memoized decision (that depends
	# on the validity period). Invoke [silent]RecallDecision to just render the
	# decision.
	$obtainGroups --print-result 0 --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --subject "$@" || :
    else
	$obtainGroups --timespan "$SETUPSOFTWARE_GROUP_VALID_TIMESPAN" --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --subject "$@" \
	    || return $?

	# Store the group selection, but only if the user actually made a permanent
	# decision (now or recalled).
	if memoizeDecision --get-decision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --subject "$@" >/dev/null 2>&1; then
	    storeSelectedDefinitionGroup "$groupSubject"
	fi
    fi
}

askTo()
{
    local subject="${1:?}"  # Don't shift off
    if $obtainPastSelection "$subject"; then
	# The stored selected definition overrules any memoized decision (that depends
	# on the validity period). Invoke [silent]RecallDecision to just render the
	# decision.
	$obtainSelection --print-result 0 --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" --subject "$@" || :
    else
	$obtainSelection --timespan "$SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN" --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" --subject "$@" \
	    || return $?

	# Store the selection, but only if the user actually made a permanent decision
	# (now or recalled), or chose to indiscriminately accept all definitions via
	# --yes.
	if [ "$obtainSelection" = 'true' ] \
	    || memoizeDecision --get-decision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" --subject "$@" >/dev/null 2>&1
	then
	    storeSelectedDefinition "$subject"
	fi
    fi
}
askToInstall()
{
    askTo "${1:?}" --verb 'is not yet' --state installed --action 'install it'
}

isAvailableNative()
{
    isAvailable${nativePackageManager:?} "$@"
}
isAvailableOrUserAcceptsNative()
{
    local beforeTypeName; if [ "$1" = --before-type ]; then shift; beforeTypeName="${1:?}"; shift; fi
    local packageManagerExecutable="${1:?}"; shift
    local packageManagerPackageName="${1:-$packageManagerExecutable}"; shift
    local packageManagerSubject="${1:-$packageManagerPackageName}"; shift

    if isAvailableNative "$packageManagerPackageName" || exists "$packageManagerExecutable"; then
	return
    fi

    if askToInstall "$packageManagerSubject"; then
	if [ -n "$beforeTypeName" ]; then
	    # Execute as a preinstall before the type's installation (e.g. the native installation of the software-properties-common package before any ppa: type is executed. The dummy ITEM is just a placeholder; it's ignored for preinstall actions.
	    eval "addedPreinstallArgs${beforeTypeName}"+='(--pre "dummy:${packageManagerPackageName}" --action "native:${packageManagerPackageName}")'
	else
	    addNative "$packageManagerPackageName"
	fi
    else
	return 1
    fi
}
isAvailableOrUserAcceptsGroup()
{
    local packageManagerExecutable="${1:?}"; shift
    local packageManagerGroup="${1:?}"; shift
    local packageManagerSubject="${1:-$packageManagerExecutable}"; shift

    if exists "$packageManagerExecutable"; then
	return
    fi

    if askToInstall "$packageManagerSubject"; then
	parseDefinitionGroups "$packageManagerGroup"
    else
	return 1
    fi
}
typeset -A dependency=()
isDependencyAvailableOrUserAcceptsNative()
{
    local dependencyExecutable="${1:?}"; shift
    local dependencyPackageName="${1:-$dependencyExecutable}"; shift
    local dependencySubject="${1:-$dependencyPackageName}"; shift
    local dependencyInstallCommand="$1"; shift

    exists "$dependencyExecutable" && return 0
    if [ ! "${dependency["$dependencyExecutable"]}" ]; then
	dependency["$dependencyExecutable"]=t
	askToInstall "$dependencySubject" || return 1

	# The preinstall cannot be directly reused any longer, because its commands are
	# now also collected and then printed / executed. (Previously, they were
	# directly executed.) For a type's dependency, we need direct execution, though.
	# We can achieve that via a special typeName "Dependency" that's not in the
	# typeRegistry to build the addedPreinstallArgsDependency, and then use a
	# special preInstall flag to directly eval() instead of just submitting the
	# commands.
	{
	    preinstallHook Dependency "$dependencyPackageName"

	    if [ -n "$dependencyInstallCommand" ]; then
		# Execute any preinstall commands from the hook first.
		preOrPostinstallCommand=eval preInstall Dependency --execute

		eval "$dependencyInstallCommand"
	    else
		# We achieve this by a recursive invocation of the readily prepared preinstall
		# action.
		# Note: Cannot use addPreinstall() because the "Dependency" typeName is not in
		# the typeRegistry. Instead, directly manipulate the array.
		addedPreinstallArgsDependency+=(--pre "dummy:${dependencyPackageName}" --action "native:${dependencyPackageName}")

		preOrPostinstallCommand=eval preInstall Dependency --execute
	    fi

	    postinstallHook Dependency "$dependencyPackageName"
	    preOrPostinstallCommand=eval postInstall Dependency --execute
	} >&2
	# When the immediate dependency action is directly executed, but not the install
	# command we're generating, this action must not produce anything on stdout, as
	# that might get captured by a client and then attempted to be executed as
	# install commands. So redirect any stdout to stderr.
    fi

    exists "$dependencyExecutable"
}

typeset -A addedItems=()
addItems()
{
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	local typeName="${typeRegistry["${prefix:-native:}"]}"
	if [ -n "$typeName" ]; then
	    "add${typeName}" "$name"
	elif [ "$prefix" = config: ]; then
	    addConfig "$name"
	elif [ "$prefix" = decorate: ]; then
	    addDecorate "$name"
	elif [ "$prefix" = preinstall: ]; then
	    addPreinstall "$name"
	elif [ "$prefix" = pre-all-install: ]; then
	    addPreOrPostinstall pre-all "$name"
	elif [ "$prefix" = postinstall: ]; then
	    addPostinstall "$name"
	elif [ "$prefix" = post-all-install: ]; then
	    addPreOrPostinstall post-all "$name"
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi || return $?
	addedItems["$item"]=t	# Record all added items for the config, decorate type / preinstall check.
    done
}
hasOrAddItems()
{
    typeset -a missingItems=()
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	if contains "$prefix" "${!definitionFilterTypeRegistry[@]}" "${!definitionGroupFilterTypeRegistry[@]}" config: decorate: preinstall: pre-all-install: postinstall: post-all-install: postinstall-or-once: post-all-install-or-once:; then
	    printf >&2 'ERROR: Cannot use a %s type within a config / decorate / pre[-all-]install / post[-all-]install[-or-once] item.\n' "$prefix"
	    exit 3
	fi

	[ ! "$isForce" ] && hasItem "$item"
	case $? in
	    0)	;;
	    98)	;;
	    99)	;;
	    *) missingItems+=("$item");;
	esac
    done

    [ ${#missingItems[@]} -eq 0 ] && return 1
    if ! addItems "${missingItems[@]}"; then
	messagePrintf 'ERROR: Failed to add missing items in %s.\n' "$(getSubjectFromItems "${missingItems[@]}")"
	return 1
    fi
}


installNative()
{
    # Do not invoke install$nativePackageManager(); as native types are
    # registered separately, their install function is invoked anyway, and that
    # will then process both native and prefixed items together.
    :
}

preOrPostInstall()
{
    local when="${1:?}"; shift
    local typeName="${1?}"; shift
    eval "typeset -a addedPreOrPostinstallArgs=(\"\${added${when^}installArgs${typeName}[@]}\")"
    eval "typeset -a addedPreOrPostinstallContextArgs=(\"\${added${when^}installContextArgs${typeName}[@]}\")"
    [ ${#addedPreOrPostinstallArgs[@]} -gt 0 ] || return

    typeset -a executeArg=(); [ "$isExecute" ] || executeArg=(--execute)    # Directly execute any pre/post-install commands; these already were authorized by the user when they executed the recursive script invocation. It's cumbersome when the execution just prints yet another command-line to be captured and executed, and especially when an automatic capture and execution is used (redirection into a file, into the bag, etc.), this printing then happens outside of the capture.
    local quotedPreOrPostInstallCommand
    printf -v quotedPreOrPostInstallCommand '%q ' "${scriptDir}/${scriptName}" "$@" "${executeArg[@]}" "${recursiveArgs[@]}" "${addedPreOrPostinstallContextArgs[@]}" "${addedPreOrPostinstallArgs[@]}"
    ${preOrPostinstallCommand:-addUniqueToBeInstalledCommand} "${quotedPreOrPostInstallCommand% }"
    eval "added${when^}installArgs${typeName}=()"
    eval "added${when^}installContextArgs${typeName}=()"
}

preInstall()
{
    preOrPostInstall pre "$@"
}
getPreinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local preinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
    do
	local preinstallFilespec="${dirspec}/${preinstallAction}"
	if [ $compareOp "$preinstallFilespec" ]; then
	    printf %s "$preinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPreInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift

    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if actionFilespec="$(getPreinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	printf -v quotedActionFilespec '%q' "$actionFilespec"
	local actionArgs="${actionWithoutSudo#"${actionWithoutSudoAndArgs}"}"
	addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${quotedActionFilespec}${actionArgs:+ }${actionArgs}"
    elif actionFilespec="$(getPreinstallFilespec -e "${action}")"; then
	local quotedPreinstallNotification; printf -v quotedPreinstallNotification %q "$actionFilespec"
	addUniqueToBeInstalledCommand "addLoginNotification --file $quotedPreinstallNotification --immediate --no-blocking-gui"
    else
	local name="${action#*:}"
	local prefix="${action%"$name"}"
	if [ "$prefix" = native: ]; then
	    # Note: Native packages would be indistinguishable from the
	    # PREINSTALL-EXPRESSION, as they have no prefix. Allow using a
	    # special "native:" prefix should it be necessary to install a
	    # package via the distribution's package manager before the main
	    # installation.
	    hasOrAddItems "${action#native:}"
	elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
	    hasOrAddItems "$action"
	else
	    addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
	fi
    fi || messagePrintf 'Skipping preinstall action, because %s indicated that no action is needed.\n' "$action"
}

postInstall()
{
    preOrPostInstall post "$@"
}
getPostinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local postinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
    do
	local postinstallFilespec="${dirspec}/${postinstallAction}"
	if [ $compareOp "$postinstallFilespec" ]; then
	    printf %s "$postinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPostInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift
    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if [ "$isForce" ] || hasItem "$item"; then
	if actionFilespec="$(getPostinstallFilespec -x "${action}")"; then
	    printf -v quotedActionFilespec '%q' "$actionFilespec"
	    addUniqueToBeInstalledCommand "$quotedActionFilespec"
	elif actionFilespec="$(getPostinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	    printf -v quotedActionFilespec '%q' "$actionFilespec"
	    local actionArgs="${actionWithoutSudo#"${actionWithoutSudoAndArgs}"}"
	    addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${quotedActionFilespec}${actionArgs:+ }${actionArgs}"
	elif actionFilespec="$(getPostinstallFilespec -e "${action}")"; then
	    local quotedPostinstallNotification; printf -v quotedPostinstallNotification %q "$actionFilespec"
	    addUniqueToBeInstalledCommand "addLoginNotification --file $quotedPostinstallNotification --immediate --no-blocking-gui"
	else
	    local name="${action#*:}"
	    local prefix="${action%"$name"}"
	    if [ "$prefix" = native: ]; then
		# Note: Native packages would be indistinguishable from the
		# POSTINSTALL-EXPRESSION, as they have no prefix. Allow using a
		# special "native:" prefix should it be necessary to install a
		# package via the distribution's package manager after a
		# successful installation.
		hasOrAddItems "${action#native:}" || \
		    messagePrintf 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
		hasOrAddItems "$action" || \
		    messagePrintf 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    else
		addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
	    fi
	fi || return 1
    else
	messagePrintf 'Skipping postinstall action, because installation of %s was not successful.\n' "$item"
    fi
}

typeset -a toBeInstalledCommands=()
addUniqueToBeInstalledCommand()
{
    local command="${1:?}"; shift
    contains "$command" "${toBeInstalledCommands[@]}" && return 1
    toBeInstalledCommands+=("$command")
}
generateInstallCommands()
{
    typeset -a typeOrdering=("${!typeInstallOrder[@]}")
    readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

    preInstall ''
    local order; for order in "${typeOrdering[@]}"
    do
	local typeName="${typeInstallOrder["$order"]}"
	preInstall "$typeName"
	    "install${typeName}"
	postInstall "$typeName"
    done
    postInstall ''
}
printInstallCommands()
{
    [ ${#toBeInstalledCommands[@]} -eq 0 ] && return 99

    if [ "$isExecute" ]; then
	local installCommandline="$(joinBy '; ' "${toBeInstalledCommands[@]}")"
	set -e +o noglob; shopt -qu nullglob
	    eval "$installCommandline" || exit $?	# Exit the script now because else installation failure would be treated as if there were no installation commands.
	set +e -o noglob; shopt -qs nullglob
    elif [ ! "$isPrintDefinitions" ] || [ "$isPrint" ]; then
	printf '%s\n' "${toBeInstalledCommands[@]}"
    fi
}
generateAndPrintInstallCommands()
{
    generateInstallCommands
    printInstallCommands
}

checkAndExit()
{
    [ $addedDefinitionCount -eq 0 ] && exit 0 || exit 1
}

acceptNoopStatus()
{
    "$@"; local status=$?
    [ $status -eq 99 ] && status=0
    return $status
}

getAbsoluteOrBaseFilespec()
{
    local subDir="${1?}"; shift
    local sourceFile="${1:?}"; shift

    if [[ ! "$sourceFile" =~ ^/ ]]; then
	local dirspec; for dirspec in "${additionalBaseDirs[@]}" "$baseDir"
	do
	    local sourceFilespec="${dirspec}/${subDir}${subDir:+/}${sourceFile}"
	    if [ -e "$sourceFilespec" ]; then
		printf %s "$sourceFilespec"
		return 0
	    fi
	done
    fi

    [[ -e "$sourceFile" || "$sourceFile" =~ ^/dev/fd/ ]] && \
	printf %s "$sourceFile" || \
	return 1
}
getAbsoluteOrFilesFilespec()
{
    getAbsoluteOrBaseFilespec files "$@"
}

readarray -t nativeTypeLibs < <(grep --files-with-matches 'nativeRegistry+=(' "${typeDir}"/*.sh)
for typeLib in "${nativeTypeLibs[@]}"
do
    source "$typeLib" || exit $?
done
case ${#nativeRegistry[@]} in
    0)	echo >&2 'ERROR: No native package management found.'; exit 3;;
    1)	readonly nativePackageManager="${nativeRegistry[0]}"
	typeRegistry[native:]="$nativePackageManager"
	;;
    *)	printf >&2 'ERROR: Multiple native package managers found: %s\n' "$(joinBy ', ' "${nativeRegistry[@]}")"; exit 3;;
esac
for typeLib in "${typeDir}"/*.sh
do
    contains "$typeLib" "${nativeTypeLibs[@]}" && continue
    source "$typeLib" || exit $?
done
set -o noglob


installExitStatus=0
noopExitStatus=4
action=generateAndPrintInstallCommands
setupName=
setupAppendix=
obtainPastSelection=false
obtainSelection=memoizeAndCacheDecision
isAddAll=
obtainPastGroupSelection=false
obtainGroups=memoizeDecision
isPrintGroups=t
typeset -a selections=()
typeset -a specialHandlingCommands=()
specialHandlingFinalCommand=
isBatch=
isPrint=
isPrintDefinitions=
isExecute=
isQuiet=
isSilenceNoDefinitions=
isVerbose=
isForce=
isRebuildSelectionStore=
typeset -a recursiveArgs=()
typeset -a setupSoftwareBehaviorArgs=()
typeset -a additionalBaseDirs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--config-help|-H)
			shift
			typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
			eval 'printConfigUsage "$@"' "${pager:+|}" '"${pager[@]}"'
			exit 0
			;;
	--check)	shift; action=checkAndExit;;
	--dry-run)	shift; action=false;;
	--base-dir)	recursiveArgs+=("$1" "$2"); shift; baseDir="${1:?}"; shift;;
	--add-base-dir)	recursiveArgs+=("$1" "$2"); shift; additionalBaseDirs=("${1:?}" "${additionalBaseDirs[@]}"); shift;;
	--print-types)	shift
			typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
			eval 'getTypePrefixesInTypeOrder "$@"' "${pager:+|}" '"${pager[@]}"'
			exit 0
			;;
	--print-definitions|-P)
			recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isPrintDefinitions=t;;
	--print|-p)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isPrint=t;;
	--execute|-e)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isExecute=t;;
	--quiet|-q)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isQuiet=t; messagePrintf() { :; };;   # Optimization: Make messagePrintf() a no-op.
	--silence-no-definitions)
			shift; isSilenceNoDefinitions=t;;
	--verbose|-v)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isVerbose=t;;
	--force|-f)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isForce=t;;
	--yes|-y)	shift; obtainSelection=true;;
	--recall-only)	obtainPastSelection=hasDefinitionBeenSelected;&	# Fall through
	--recall-current-only)
			shift
			if [ "$isQuiet" ]; then
			    obtainSelection=silentRecallDecision
			else
			    obtainSelection=recallDecision
			fi
			;;
	--batch|-b)	recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isBatch=t;;
	--select|-s)	shift; selections+=("$1"); shift;;
	--all|-a)	shift; isAddAll=t;;
	--group-recall-only)
			obtainPastGroupSelection=hasDefinitionGroupBeenSelected;& # Fall through
	--group-recall-current-only)
			shift
			if [ "$isQuiet" ]; then
			    obtainGroups=silentRecallDecision
			else
			    obtainGroups=recallDecision
			fi
			isPrintGroups=
			;;
	--clear-group-recall)
			shift
			specialHandlingCommands+=('memoizeDecision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --delete-all-decisions')
			;;
	--clear-definition-recall)
			shift
			specialHandlingCommands+=('memoizeDecision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" --delete-all-decisions')
			;;
	--clear-selection-store)
			shift
			specialHandlingCommands+=('selectedDefinitionDatabase --truncate')
			specialHandlingCommands+=('selectedDefinitionGroupDatabase --truncate')
			;;
	--rebuild-selection-store)
			recursiveArgs+=("$1"); setupSoftwareBehaviorArgs+=("$1"); shift; isRebuildSelectionStore=t;;
	--name)		shift; setupName="${1:?}"; shift;;
	--key-database)	shift; keyDatabase "$@"; exit $?;;
	--key-value-database)
			shift; keyValueDatabase "$@"; exit $?;;
	--pre)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --pre %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			printf -v specialCommand 'runPreInstallCheck %q %q' "$item" "$specialAction"
			specialHandlingCommands+=("$specialCommand")
			specialHandlingFinalCommand='acceptNoopStatus generateAndPrintInstallCommands'
			;;
	--post-context)	shift; eval "$1"; shift;;
	--post)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q' "$item" "$specialAction"
			specialHandlingCommands+=("${specialCommand% }")
			specialHandlingFinalCommand='acceptNoopStatus generateAndPrintInstallCommands'
			;;
	--post-or-once)	shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			if [ "$1" != '--id' ]; then
			    printf >&2 'ASSERT: No --id following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; id="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q && onceMarker --update %q' "$item" "$specialAction" "$id"
			specialHandlingCommands+=("${specialCommand% }")
			specialHandlingFinalCommand='acceptNoopStatus generateAndPrintInstallCommands'
			;;
	--)		shift; break;;
	-*)		if [ -n "${commandLineOptions["$1"]}" ]; then
			    "${commandLineOptions["$1"]}" "$1"
			    shift
			elif [ -n "${commandLineParameters["$1"]}" ]; then
			    "${commandLineParameters["$1"]}" "$1" "$2"
			    shift; shift
			else
			    echo "ERROR: Unknown option \"$1\"!"
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	*)		break;;
    esac
done
if [ -t 1 ] && [ ! "$isExecute" ] && [ ! "$isPrint" ] && [ ! "$isPrintDefinitions" ] && [ ${#specialHandlingCommands[@]} -eq 0 ] && [ ! "$isRebuildSelectionStore" ]; then
    echo >&2 'ERROR: Will not output installation commands to the terminal without -p|--print; either redirect output or directly execute via -e|--execute, or just print defintitions with -P|--print-definitions.'
    echo >&2
    printUsage "$0" >&2
    exit 2
elif [ "$isExecute" ] && [ "$isPrint" ]; then
    echo >&2 'ERROR: Cannot combine -e|--execute with -p|--print.'
    echo >&2
    printUsage "$0" >&2
    exit 2
fi

SETUPSOFTWARE_BEHAVIOR_ARGS=; if [ ${#setupSoftwareBehaviorArgs[@]} -gt 0 ]; then printf -v SETUPSOFTWARE_BEHAVIOR_ARGS ' %q ' "${setupSoftwareBehaviorArgs[@]}"; export SETUPSOFTWARE_BEHAVIOR_ARGS="${SETUPSOFTWARE_BEHAVIOR_ARGS% }"; fi    # The array cannot be directly consumed, as checks are invoked through another process (invocationMessage); use the exported environment variable instead.
typeset -a preinstallActionsDirspecs=()
typeset -a postinstallActionsDirspecs=()
typeset -a definitionDirspecs=()

for dirspec in "${additionalBaseDirs[@]}" "$baseDir"
do
    [ -d "${dirspec}/preinstall" ]  && preinstallActionsDirspecs+=("${dirspec}/preinstall")
    [ -d "${dirspec}/postinstall" ] && postinstallActionsDirspecs+=("${dirspec}/postinstall")
    [ -d "${dirspec}/definitions" ] && definitionDirspecs+=("${dirspec}/definitions")
done
[ -n "$setupName" ] || createSetupName "${additionalBaseDirs[@]}" "$baseDir"

typeset -ra passedGroups=("$@"); set --
if [ "$isAddAll" ]; then
    addAllAcceptedGroups
    if [ ${#acceptedGroups[@]} -eq 0 ]; then
	exit 4
    else
	acceptedGroupsPlural=s; [ ${#acceptedGroups[@]} -eq 1 ] && acceptedGroupsPlural=
	messagePrintf '\nOkay, %d definition group%s selected. Now for the definitions themselves:\n\n' "${#acceptedGroups[@]}" "$acceptedGroupsPlural"
    fi
fi
if [ ${#specialHandlingCommands[@]} -gt 0 ]; then
    status=0
    for specialCommand in "${specialHandlingCommands[@]}"
    do
	eval "$specialCommand" || status=1
    done
    eval "$specialHandlingFinalCommand" || status=1
    exit $status
elif [ ! "$isAddAll" ] && [ ${#passedGroups[@]} -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

IFS=' '
let handledDefinitionCount=0
let missingDefinitionCount=0
let addedDefinitionCount=0
setupAppendix=
parseDefinitionGroups "${acceptedGroups[@]}" "${passedGroups[@]}" || exit $?

$action && exit $installExitStatus

status=$noopExitStatus
if [ $handledDefinitionCount -gt 0 ]; then
    if [ $addedDefinitionCount -gt 0 ]; then
	definitionsVerb=are; definitionsPlural=s; [ $handledDefinitionCount -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	messagePrintf '%d out of %d offered definition%s would be installed.\n' "$addedDefinitionCount" "$handledDefinitionCount" "$definitionsPlural"
	status=$installExitStatus
    elif [ $missingDefinitionCount -gt 0 ]; then
	missingDefinitionCountPlural=s; missingDefinitionCountAuxilliaryVerb=were; [ $missingDefinitionCount -eq 1 ] && { missingDefinitionCountPlural=; missingDefinitionCountAuxilliaryVerb=was; }
	messagePrintf '%d not yet installed definition%s %s declined.\n' "$missingDefinitionCount" "$missingDefinitionCountPlural" "$missingDefinitionCountAuxilliaryVerb"
    else
	definitionsVerb=are; definitionsPlural=s; [ $handledDefinitionCount -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	messagePrintf '%d definition%s %s already installed.\n' "$handledDefinitionCount" "$definitionsPlural" "$definitionsVerb"
    fi
elif [ $definitionCnt -gt 0 ]; then
    skippedDefinitionsVerb=have; skippedDefinitionsPlural=s; [ $definitionCnt -eq 1 ] && { skippedDefinitionsVerb=has; skippedDefinitionsPlural= ; }
    messagePrintf '%d definition%s %s been skipped.\n' $definitionCnt "$skippedDefinitionsPlural" "$skippedDefinitionsVerb"
fi
exit $status
