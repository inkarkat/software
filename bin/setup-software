#!/bin/bash
set -o noglob
shopt -qs extglob

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
readonly projectDir="${scriptDir}/.."
baseDir="${projectDir}/etc"
readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"

SUDO='sudo --set-home'; [ $EUID -eq 0 ] && SUDO=''  # Use root's home; especially pip3 writes to ~/.cache/pip and complains if the files belong to another user.

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-v|--verbose] [-y|--yes] [-s|--select DEFINITION [-s ...]] [--base-dir BASE-DIR] -a|--all|GROUP-NAME|GROUP-FILESPEC [...] [-?|-h|--help]|[-H|--config-help [TYPE]]'
    echo
    printf 'Usage: packageInstallCommandLine="$(%q %s)" && eval "$packageInstallCommandLine"\n' "$(basename "$1")" '--yes [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Guided wizard to interactively choose / take (with -y|--yes) (from DEFINITION(s)
/ all / the passed GROUP(s)) and install various common software that I use.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --config-help|-H [TYPE]
			Show details about the configuration syntax for all /
			for TYPE.
    --verbose|-v	Also mention already installed definitions that are
			skipped.
    --yes|-y		Accept all definitions (that are not yet installed and
			have been chosen) without the usual interactive query.
    --select|-s	DEFINITION
			Choose DEFINITION, which must exactly match the COMMENT
			in a definition if one exists or the exact list of ITEMs
			(with definitions broken over multiple lines already
			joined), instead of considering all from the passed
			GROUP(s).
    --base-dir BASE-DIR	Reference definitions, custom actions, pre-, and
			post-install actions from BASE-DIR instead of using
			those bundled with this project.
    --all|-a		Consider definitions from all existing definition
			groups.
    GROUP-NAME		Consider definitions from GROUP-NAME, as stored inside
			this project / BASE-DIR.
    GROUP-FILESPEC	Consider definitions from GROUP-FILESPEC, which can
			point to anywhere in the file system.
HELPTEXT
}

printConfigUsage()
{
    cat <<'HELPTEXT'
A definition consists of one or many whitespace-separated ITEMs, optionally
followed by a # DESCRIPTION. It can be broken over multiple lines, with a
trailing \ as the line continuation character.
Definitions are grouped into DEFINITION-GROUPs which contain definitions that
belong to a certain category or are typically installed together for a certain
use case.
HELPTEXT
    echo
    local padding=
    case "$1" in
	'') cat <<'HELPTEXT'
Items without a prefix refer to packages installed via the distribution's
package manager (apt).
HELPTEXT
	    padding='\n'
	    ;;&
	''|ppa)	cat <<'HELPTEXT'
ppa: items refer to Ubuntu personal package archives that enable additional
packages (or other versions) to be installed through apt.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|deb-build) cat <<'HELPTEXT'
deb-build: items refer to packages that satisfy the build dependencies for a
source package.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|deb+url) cat <<'HELPTEXT'
deb+url: items consist of a
    PACKAGE[:MAX-AGE[SUFFIX]]:[[SUBDIR/]NAME/]PACKAGE-GLOB:[URL]
triplet / quadruplet.
If ~/install/(SUBDIR|*)/(NAME|*)/PACKAGE-GLOB already exists [and if it is
younger than MAX-AGE[SUFFIX]], it will be used; else, the *.deb from URL will
be downloaded (and put into ~/install/* if it exists). If no URL is given and
the package does not exist, the installation will fail.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|snap) cat <<'HELPTEXT'
snap: items refer to packages from the Snap store that work across many
different Linux distributions, are segregated and update automatically.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|pip3)    cat <<'HELPTEXT'
pip3: items refer to the Python package installer.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|npm)	cat <<'HELPTEXT'
npm: items refer to the Node.js package (or "Node modules") installer.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|wine+url)	cat <<'HELPTEXT'
wine+url: items consist of a
    EXECUTABLE-NAME?[:MAX-AGE[SUFFIX]]:[[SUBDIR/]NAME/]PACKAGE-GLOB:[URL]
triplet / quadruplet.
If EXECUTABLE-NAME? (located in Wine's drive C: unless it's an absolute path)
exists / resolves to an existing file or directory, the item is deemed already
installed.
Else if ~/install/(SUBDIR|*)/(NAME|*)/PACKAGE-GLOB already exists [and if it is
younger than MAX-AGE[SUFFIX]], it will be used; else, the *.exe / *.msi from URL
will be downloaded (and put into ~/install/* if it exists). If no URL is given
and the package does not exist, the installation will fail.
HELPTEXT
	    printf "$padding"
	    ;;&
	''|custom)  cat <<'HELPTEXT'
custom: items consist of a CHECK:ACTION pair.
CHECK can be one of the following (in decreasing precedence):
- an EXECUTABLE-COMMAND in the ./etc/custom directory tree that is called and
  should succeed if the application already exists, and fail if it is missing;
  if EXECUTABLE-COMMAND starts with a &, this is replaced by the following
  ACTION (without a $SUDO prefix), allowing you to save repeated typing:
	custom:&-check:foo-installer
- an EXECUTABLE-NAME? (located through $PATH) or GLOB?, and succeeds if
  it's there / resolves to an existing file or directory
- the special expression "false"; then, no check is performed and whether the
  installation action will happen depends solely on the (potentially recalled or
  derived from the whole definition) user's answer
- a TEST-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd and should succeed if the application already
  exists, and fail if it is missing; if TEST-EXPRESSION starts with a &, this
  is replaced by the following ACTION (without a $SUDO prefix), allowing you
  to re-use the same script for checking and installing:
	custom:'& --check':foo-installer
    or save repeated typing:
	custom:&-check:foo-installer
ACTION is one of the following:
- an executable command in the ./etc/custom directory tree that is invoked
  (prepend $SUDO if it needs to be invoked as root) and should then install
  the application
- a text file in the ./etc/custom directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual installation steps)
  immediately and on each login until the user acknowledges it
- an INSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
HELPTEXT
	    printf "$padding"
	    ;;&
	''|preinstall)	cat <<'HELPTEXT'
preinstall: items consist of an ACTION that is one of the following:
- an executable command in the ./etc/preinstall directory tree that is invoked
  (prepend $SUDO if it needs to be invoked as root) and should then perform the
  preinstallation steps
- a text file in the ./etc/preinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual pre-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a PREINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A preinstall item runs (before other installation actions) if the
non-pre/postinstall item preceding it in the current definition is missing, but
the definition has now been selected.
HELPTEXT
	    ;;&
	''|postinstall)	cat <<'HELPTEXT'
postinstall: items consist of an ACTION that is one of the following:
- an executable command in the ./etc/postinstall directory tree that is invoked
  (prepend $SUDO if it needs to be invoked as root) and should then perform the
  postinstallation steps
- a text file in the ./etc/postinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual post-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a POSTINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A postinstall item runs if the non-pre/postinstall item preceding it in the
current definition was missing, but has been successfully installed by the
installation commands.
HELPTEXT
	    ;;&
    esac
}

typeset -A typeRegistry=([native]=Native [ppa:]=Ppa [build-dep:]=DebBuild [deb+url:]=DebUrl [snap:]=Snap [pip3:]=Pip3 [npm:]=Npm [wine+url:]=Wine [custom:]=Custom)
typeset -A typeInstallOrder=([1]=Ppa [10]=Native [20]=DebBuild [30]=DebUrl [100]=Snap [200]=Pip3 [300]=Npm [400]=Wine [1000]=Custom)

typeset -a acceptedGroups=()
addAllAcceptedGroups()
{
    local group; while IFS=$'\n' read -r group
    do
	group="${group#./}"
	memoizeDecision --memoize-group setup-software-groups --subject "$group" --verb 'is not' --state 'chosen' --action 'consider it' && \
	    acceptedGroups+=("$group")
    done < <(cd "$definitionDirspec" && find . -type f -print | sort)
}

database()
{
    picoDB --base-type data --namespace setup-software --table "$@"
}

typeset -A installedPackages=()
isInstalledPackagesAvailable=
getInstalledPackages()
{
    [ "$isInstalledPackagesAvailable" ] && return

    local package; while IFS=$'\n' read -r package
    do
	installedPackages["$package"]=t
	case ",${DEBUG:-}," in *,setup-software:pkg,*) echo >&2 "${PS4}setup-software (pkg): Found installed ${package}";; esac
    done < <(dpkg-package-list)

    if [ ${#installedPackages[@]} -eq 0 ]; then
	echo >&2 'ERROR: Failed to obtain installed package list.'
	exit 3
    fi

    isInstalledPackagesAvailable=t
}
hasNative()
{
    # If a package retrieval fails, treat this as an existing item, so that
    # these are effectively skipped.
    ! getInstalledPackages || [ "${installedPackages["${1:?}"]}" ]
}
addNative()
{
    addedPackages+=("${1:?}")
}

typeset -A installedPpaRepositories=()
isInstalledPpaRepositoriesAvailable=
getInstalledPpaRepositories()
{
    [ "$isInstalledPpaRepositoriesAvailable" ] && return

    local repo; while IFS=$'\n' read -r repo
    do
	installedPpaRepositories["${repo#ppa:}"]=t
	case ",${DEBUG:-}," in *,setup-software:ppa,*) echo >&2 "${PS4}setup-software (ppa): Found installed ppa:${repo}";; esac
    done < <(apt-list-repositories --ppa-only)

    isInstalledPpaRepositoriesAvailable=t
}
hasPpa()
{
    ! getInstalledPpaRepositories || [ "${installedPpaRepositories["${1:?}"]}" ]
}
addPpa()
{
    addedPpaRepositories+=("${1:?}")
}

typeset -A installedDebBuildDependencies=()
isInstalledDebBuildDependenciesAvailable=
getInstalledDebBuildDependencies()
{
    [ "$isInstalledDebBuildDependenciesAvailable" ] && return

    eval "$(database debBuildDependencies --get-as-dictionary installedDebBuildDependencies --omit-declaration)" || exit 3

    [ ${#installedDebBuildDependencies[@]} -gt 0 ] &&
	case ",${DEBUG:-}," in *,setup-software:deb-build,*) echo >&2 "${PS4}setup-software (deb-build): Found installed ${!installedDebBuildDependencies[*]}";; esac

    isInstalledDebBuildDependenciesAvailable=t
}
hasDebBuild()
{
    ! getInstalledDebBuildDependencies|| [ "${installedDebBuildDependencies["${1:?}"]}" ]
}
addDebBuild()
{
    hasDebSrc && addedDebBuildDependencies+=("${1:?}")
}

hasDebUrl()
{
    ! getInstalledPackages || [ "${installedPackages["${1%%:*}"]}" ]
}
addDebUrl()
{
    addedDebUrlPackages+=("${1:?}")
}

typeset -A installedSnapPackages=()
isInstalledSnapPackagesAvailable=
getInstalledSnapPackages()
{
    [ "$isInstalledSnapPackagesAvailable" ] && return

    local packageName remainder; while IFS=' ' read -r packageName remainder
    do
	case "$packageName" in
	    Name)	    continue;;	# Skip single-line header
	    *)		    installedSnapPackages["$packageName"]=t
			    case ",${DEBUG:-}," in *,setup-software:snap,*) echo >&2 "${PS4}setup-software (snap): Found installed ${packageName}";; esac
			    ;;
	esac
    done < <(snap list --color=never --unicode=never 2>/dev/null)

    isInstalledSnapPackagesAvailable=t
}
hasSnap()
{
    ! getInstalledSnapPackages || [ "${installedSnapPackages["${1:?}"]}" ]
}
addSnap()
{
    isAvailable snap snapd && addedSnapPackages+=("${1:?}")
}

typeset -A installedPip3Packages=()
isInstalledPip3PackagesAvailable=
getInstalledPip3Packages()
{
    [ "$isInstalledPip3PackagesAvailable" ] && return

    local packageName remainder; while IFS=' ' read -r packageName remainder
    do
	case "$packageName" in
	    Package|+(-))   continue;;	# Skip 2-line header
	    *)		    installedPip3Packages["$packageName"]=t
			    case ",${DEBUG:-}," in *,setup-software:pip3,*) echo >&2 "${PS4}setup-software (pip3): Found installed ${packageName}";; esac
			    ;;
	esac
    done < <(pip3 list 2>/dev/null)

    isInstalledPip3PackagesAvailable=t
}
hasPip3()
{
    ! getInstalledPip3Packages || [ "${installedPip3Packages["${1:?}"]}" ]
}
addPip3()
{
    isAvailable pip3 && addedPip3Packages+=("${1:?}")
}

typeset -A installedNpmPackages=()
isInstalledNpmPackagesAvailable=
getInstalledNpmPackages()
{
    [ "$isInstalledNpmPackagesAvailable" ] && return

    local packageDirspec; while IFS=$'\n' read -r packageDirspec
    do
	local packageName; packageName="${packageDirspec##*/}"
	if [ -n "$packageName" ]; then
	    installedNpmPackages["$packageName"]=t
	    case ",${DEBUG:-}," in *,setup-software:npm,*) echo >&2 "${PS4}setup-software (npm): Found installed ${packageName}";; esac
	fi
    done < <(npm ls --global --parseable --depth 0 2>/dev/null)

    isInstalledNpmPackagesAvailable=t
}
hasNpm()
{
    ! getInstalledNpmPackages || [ "${installedNpmPackages["${1:?}"]}" ]
}
addNpm()
{
    isAvailable npm && addedNpmPackages+=("${1:?}")
}

hasWine()
{
    if [[ ! "$1" =~ ^[^:]+\?:.+: ]]; then
	printf >&2 'ERROR: Invalid wine+url item: "wine+url:%s"\n' "$1"
	exit 3
    fi
    local checkGlob="${1%%:*}"

    local -r wineDriveC=~/.wine/drive_c
    if [[ ! "$checkGlob" =~ ^/ ]] && [ -d "$wineDriveC" ]; then
	which "${wineDriveC}/${checkGlob%\?}" >/dev/null 2>&1 || expandglob -- "${wineDriveC}/${checkGlob%\?}" >/dev/null 2>&1 && return 0
    fi
    which "${checkGlob%\?}" >/dev/null 2>&1 || expandglob -- "${checkGlob%\?}" >/dev/null 2>&1
}
addWine()
{
    isAvailable wine && addedWineUrlPackages+=("${1:?}")
}

hasCustom()
{
    local customAction="${1#*:}"
    local customCheck="${1%:$customAction}"
    local customActionWithoutSudo="${customAction#\$SUDO }"

    if [ -z "$customAction" -o -z "$customCheck" ]; then
	printf >&2 'ERROR: Invalid custom item: "custom:%s"\n' "$1"
	exit 3
    fi

    if [ -x "${customActionsDirspec}/${customCheck}" ]; then
	"${customActionsDirspec}/${customCheck}"
    elif [[ "$customCheck" =~ \?$ ]] && local customCheckLikeAction="${customActionsDirspec}/${customActionWithoutSudo}${customCheck#\&}" && [ -x "$customCheckLikeAction" ]; then
	"$customCheckLikeAction"
    elif [[ "$customCheck" =~ \?$ ]]; then
	which "${customCheck%\?}" >/dev/null 2>&1 || expandglob -- "${customCheck%\?}" >/dev/null 2>&1
    else
	if [[ "$customCheck" =~ ^\& ]]; then
	    if [ -x "${customActionsDirspec}/${customActionWithoutSudo}" ]; then
		customActionWithoutSudo="${customActionsDirspec}/${customActionWithoutSudo}"
	    fi
	    customCheck="${customActionWithoutSudo}${customCheck#\&}"
	fi

	eval "$customCheck"
    fi
}
addCustom()
{
    addedCustomActions+=("${1#*:}")
}

addPreinstall()
{
    local name="${1:?}"; shift
    if [ "${addedItems["${name#*$'\n'}"]}" ]; then
	# Convert the "preinstall:ACTION\nITEM" to --pre "$ITEM" --action
	# "$ACTION" and do a recursive invocation now, in order to print the
	# preinstallation commands before anything else. This cannot be done
	# within this script's scope, as preinstall items that reference another
	# ITEM will populate all the addedITEM* arrays, and everything will be
	# intermingled and later printed type by type in the static order, but
	# the purpose of preinstall is to execute stuff before anything else.
	"${scriptDir}/${scriptName}" "${recursiveArgs[@]}" --pre "${name#*$'\n'}" --action "${name%%$'\n'*}"
    fi
}
addPostinstall()
{
    local name="${1:?}"; shift
    # Convert the "postinstall:ACTION\nITEM" to
    # --post "$ITEM" --action "$ACTION".
    addedPostinstallArgs+=(--post "${name#*$'\n'}" --action "${name%%$'\n'*}")
}

hasItem()
{
    local item="${1:?}"; shift
    local name="${item#*:}"
    local prefix="${item%"$name"}"

    local typeFunction="${typeRegistry["${prefix:-native}"]}"
    if [ -n "$typeFunction" ]; then
	eval "has${typeFunction} \"\$name\""
    else
	printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	exit 3
    fi
}

askTo()
{
    memoizeDecision --memoize-group setup-software "$@"
}

typeset -a addedPackages=()
typeset -a addedPpaRepositories=()
typeset -a addedDebBuildDependencies=()
typeset -a addedDebUrlPackages=()
typeset -a addedSnapPackages=()
typeset -a addedPip3Packages=()
typeset -a addedNpmPackages=()
typeset -a addedWineUrlPackages=()
typeset -a addedCustomActions=()
typeset -a addedPostinstallArgs=()
hasDebSrc()
{
    local APT_SOURCES=/etc/apt/sources.list
    grep --quiet -e '^deb-src' "$APT_SOURCES" && return

    if askTo --subject 'deb-src' --verb 'are not yet' --state 'enabled in sources.list' --action 'enable them'; then
	local debSrcEnable; printf -v debSrcEnable %q "${projectDir}/lib/enableDebSrc.sh"
	toBeInstalledCommands+=("${SUDO}${SUDO:+ }$debSrcEnable $APT_SOURCES")
    else
	return 1
    fi
}
isAvailable()
{
    local packageManager="${1:?}"; shift
    local packageManagerName="${1:-$packageManager}"; shift

    if [ "${installedPackages["$packageManager"]}" ] || [ "${addedPackages["$packageManager"]}" ] || exists "$packageManager"; then
	return
    fi

    if askTo --subject "$packageManagerName" --verb 'is not yet' --state installed --action 'install it'; then
	# Allow special pre- and post-install steps for implicitly added package manager packages.
	local actionScript
	for actionScript in "${preinstallActionsDirspec}/${packageManagerName}"/*
	do
	    [ -x "$actionScript" ] && "${scriptDir}/${scriptName}" "${recursiveArgs[@]}" --pre "$packageManagerName" --action "${actionScript#"${preinstallActionsDirspec}/${packageManagerName}/"}"
	done

	addedPackages+=("$packageManagerName")

	for actionScript in "${postinstallActionsDirspec}/${packageManagerName}"/*
	do
	    [ -x "$actionScript" ] && addedPostinstallArgs+=(--post "$packageManagerName" --action "${actionScript#"${postinstallActionsDirspec}/${packageManagerName}/"}")
	done
    else
	return 1
    fi
}
typeset -A addedItems=()
addItems()
{
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	local typeFunction="${typeRegistry["${prefix:-native}"]}"
	if [ -n "$typeFunction" ]; then
	    eval "add${typeFunction} \"\$name\""
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	addedItems["$item"]=t	# Record all added items for the preinstall check.
    done
}


installNative()
{
    [ ${#addedPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt install ${addedPackages[*]}")
}

installPpa()
{
    [ ${#addedPpaRepositories[@]} -gt 0 ] || return
    local repo; for repo in "${addedPpaRepositories[@]}"
    do
	toBeInstalledCommands+=("${SUDO}${SUDO:+ }add-apt-repository ppa:$repo")
    done
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt update")
}

installDebBuild()
{
    [ ${#addedDebBuildDependencies[@]} -gt 0 ] || return

    local databaseUpdate; printf -v databaseUpdate %q "${scriptDir}/${scriptName}"
    local buildDep; for buildDep in "${addedDebBuildDependencies[@]}"
    do
	toBeInstalledCommands+=("${SUDO}${SUDO:+ }apt-get build-dep $buildDep && ${databaseUpdate}${isVerbose:+ --verbose} --database debBuildDependencies --add $buildDep")
    done
}

installDebUrl()
{
    [ ${#addedDebUrlPackages[@]} -gt 0 ] || return
    local debUrlRecord; for debUrlRecord in "${addedDebUrlPackages[@]}"
    do
	local maxAge=
	local packageNameGlobUrl="${debUrlRecord#*:}"
	if [[ "$packageNameGlobUrl" =~ ^[0-9]+([smhdwyg]|mo): ]]; then
	    maxAge="${BASH_REMATCH[0]%:}"
	    packageNameGlobUrl="${packageNameGlobUrl#"${BASH_REMATCH[0]}"}"
	fi
	local packageUrl="${packageNameGlobUrl#*:}"
	local packageNameAndGlob="${packageNameGlobUrl%:$packageUrl}"
	local packageGlob="${packageNameAndGlob##*/}"
	local packageName="${packageNameAndGlob%"$packageGlob"}"
	packageName="${packageName%/}"

	# Note: No sudo here, as the downloading will happen as the current user
	# and only the installation itself will be done through sudo.
	toBeInstalledCommands+=("deb-download-installer${packageName:+ --application-name "'"}${packageName}${packageName:+"'"} --expression '$packageGlob'${maxAge:+ --max-age }$maxAge --url '$packageUrl'")
    done
}

installSnap()
{
    [ ${#addedSnapPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }snap install ${addedSnapPackages[*]}")
}

installPip3()
{
    [ ${#addedPip3Packages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }pip3 install ${addedPip3Packages[*]}")
}

installNpm()
{
    [ ${#addedNpmPackages[@]} -gt 0 ] || return
    local IFS=' '
    toBeInstalledCommands+=("${SUDO}${SUDO:+ }npm install --global ${addedNpmPackages[*]}")
}

installWine()
{
    [ ${#addedWineUrlPackages[@]} -gt 0 ] || return
    local wineUrlRecord; for wineUrlRecord in "${addedWineUrlPackages[@]}"
    do
	local maxAge=
	local packageNameGlobUrl="${wineUrlRecord#*:}"
	if [[ "$packageNameGlobUrl" =~ ^[0-9]+([smhdwyg]|mo): ]]; then
	    maxAge="${BASH_REMATCH[0]%:}"
	    packageNameGlobUrl="${packageNameGlobUrl#"${BASH_REMATCH[0]}"}"
	fi
	local packageUrl="${packageNameGlobUrl#*:}"
	local packageNameAndGlob="${packageNameGlobUrl%:$packageUrl}"
	local packageGlob="${packageNameAndGlob##*/}"
	local packageName="${packageNameAndGlob%"$packageGlob"}"
	packageName="${packageName%/}"

	# Note: No sudo here, as downloading and installation will happen as the
	# current user.
	toBeInstalledCommands+=("wine-download-installer${packageName:+ --application-name "'"}${packageName}${packageName:+"'"} --expression '$packageGlob'${maxAge:+ --max-age }$maxAge --url '$packageUrl'")
    done
}

installCustom()
{
    [ ${#addedCustomActions[@]} -gt 0 ] || return

    local customAction; for customAction in "${addedCustomActions[@]}"
    do
	local customActionWithoutSudo="${customAction#\$SUDO }"
	local sudoPrefix="${customAction%"$customActionWithoutSudo"}"

	if [ -x "${customActionsDirspec}/${customActionWithoutSudo}" ]; then
	    customActionWithoutSudo="${customActionsDirspec}/${customActionWithoutSudo}"
	elif [ -e "${customActionsDirspec}/${customAction}" ]; then
	    local quotedCustomNotification; printf -v quotedCustomNotification %s "${customActionsDirspec}/${customAction}"
	    toBeInstalledCommands+=("addLoginNotification --file $quotedCustomNotification --immediate")
	    continue
	fi
	toBeInstalledCommands+=("${sudoPrefix:+${SUDO}${SUDO:+ }}${customActionWithoutSudo}")
    done
}

preInstall()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift

    local actionWithoutSudo="${action#\$SUDO }"
    if [ -x "${preinstallActionsDirspec}/${actionWithoutSudo}" ]; then
	actionWithoutSudo="${preinstallActionsDirspec}/${actionWithoutSudo}"
	toBeInstalledCommands+=("${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}")
    elif [ -e "${preinstallActionsDirspec}/${action}" ]; then
	local quotedPreinstallNotification; printf -v quotedPreinstallNotification %s "${preinstallActionsDirspec}/${action}"
	toBeInstalledCommands+=("addLoginNotification --file $quotedPreinstallNotification --immediate --no-blocking-gui")
    else
	local name="${action#*:}"
	local prefix="${action%"$name"}"
	case "$prefix" in
	    # Note: Native packages would be indistinguishable from the
	    # PREINSTALL-EXPRESSION, as they have no prefix. Allow using a
	    # special "native:" prefix should it be necessary to install a
	    # package via the distribution's package manager before the main
	    # installation.
	    native:)
		addItems "${action#native:}"
		generateInstallCommands
		;;
	    ppa:|build-dep:|deb+url:|snap:|pip3:|npm:|wine+url:|custom:)
		addItems "$action"
		generateInstallCommands
		;;
	    *)
		toBeInstalledCommands+=("${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}")
		;;
	esac
    fi

    printInstallCommands || \
	printf >&2 'Skipping preinstall action, because %s indicated that no action is needed.\n' "$action"
}

postInstall()
{
    [ ${#addedPostinstallArgs[@]} -gt 0 ] || return

    local quotedPostInstallCommand
    printf -v quotedPostInstallCommand '%q ' "${scriptDir}/${scriptName}" "${recursiveArgs[@]}" "${addedPostinstallArgs[@]}"
    toBeInstalledCommands+=("${quotedPostInstallCommand% }")
}
runPostInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift
    local actionWithoutSudo="${action#\$SUDO }"
    if hasItem "$item"; then
	if [ -x "${postinstallActionsDirspec}/${action}" ]; then
	    "${postinstallActionsDirspec}/${action}"
	elif [ -x "${postinstallActionsDirspec}/${actionWithoutSudo}" ]; then
	    $SUDO "${postinstallActionsDirspec}/${actionWithoutSudo}"
	elif [ -e "${postinstallActionsDirspec}/${action}" ]; then
	    addLoginNotification --file "${postinstallActionsDirspec}/${action}" --immediate
	else
	    local name="${action#*:}"
	    local prefix="${action%"$name"}"
	    case "$prefix" in
		# Note: Native packages would be indistinguishable from the
		# POSTINSTALL-EXPRESSION, as they have no prefix. Allow using a
		# special "native:" prefix should it be necessary to install a
		# package via the distribution's package manager after a
		# successful installation.
		native:)
		    addItems "${action#native:}"
		    printInstallCommands || \
			printf >&2 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
		    ;;
		ppa:|build-dep:|deb+url:|snap:|pip3:|npm:|wine+url:|custom:)
		    addItems "$action"
		    generateInstallCommands
		    printInstallCommands || \
			printf >&2 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
		    ;;
		*)
		    eval "$action";;
	    esac
	fi || return 1
    else
	printf >&2 'Skipping postinstall action, because installation of %s was not successful.\n' "$item"
    fi
}

generateInstallCommands()
{
    typeset -a typeOrdering=("${!typeInstallOrder[@]}")
    readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

    local order; for order in "${typeOrdering[@]}"
    do
	local typeFunction="${typeInstallOrder["$order"]}"
	eval "install${typeFunction}"
    done

    postInstall
}
printInstallCommands()
{
    [ ${#toBeInstalledCommands[@]} -eq 0 ] && return 1
    printf '%s\n' "${toBeInstalledCommands[@]}"
}


obtainSelection=askTo
typeset -a selections=()
prePostStatus=
isVerbose=
typeset -a recursiveArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--config-help|-H)
			shift
			typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
			eval 'printConfigUsage "$@"' "${pager:+|}" '"${pager[@]}"'
			exit 0
			;;
	--base-dir)	recursiveArgs+=("$1" "$2"); shift; baseDir="${1:?}"; shift;;
	--verbose|-v)	recursiveArgs+=("$1"); shift; isVerbose=t;;
	--yes|-y)	shift; obtainSelection=true;;
	--select|-s)	shift; selections+=("$1"); shift;;
	--all|-a)	shift
			addAllAcceptedGroups
			if [ ${#acceptedGroups[@]} -eq 0 ]; then
			    exit 1
			else
			    set -- "${acceptedGroups[@]}" "$@"
			fi
			;;
	--database)	shift; database "$@"; exit $?;;
	--pre)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --pre %q.\n' "$item"; exit 3
			fi
			shift; action="$1"; shift
			: ${prePostStatus:=0}
			preInstall "$item" "$action" || prePostStatus=1
			;;
	--post)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post %q.\n' "$item"; exit 3
			fi
			shift; action="$1"; shift
			: ${prePostStatus:=0}
			runPostInstallCheck "$item" "$action" || prePostStatus=1
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ -n "$prePostStatus" ] && exit $prePostStatus
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

IFS=' '
customActionsDirspec="${baseDir}/custom"
preinstallActionsDirspec="${baseDir}/preinstall"
postinstallActionsDirspec="${baseDir}/postinstall"
definitionDirspec="${baseDir}/definitions"

typeset -a definitions=()
for definitionFile
do
    if [ -f "${definitionDirspec}/${definitionFile}" -a "${definitionFile:0:1}" != '.' ]; then
	definitionFilespec="${definitionDirspec}/${definitionFile}"
    elif [ -f "${definitionFile}" ]; then
	definitionFilespec="$definitionFile"
    else
	printf >&2 'ERROR: Definition "%s" does not exist.\n' "$definitionFile"
	exit 2
    fi

    while IFS=$'\n' read -r line
    do
	while [[ "$line" =~ \\$ ]]
	do
	    IFS=$'\n' read -r nextLine
	    line="${line%\\}$nextLine"
	done
	[[ "$line" =~ ^[[:space:]]*# ]] && continue
	[[ "$line" =~ ^[[:space:]]*$ ]] && continue


	if [ ${#selections[@]} -eq 0 ]; then
	    definitions+=("$line")
	else
	    items="${line%%[	 ]#*}"
	    comment="${line#"$items"}"
	    comment="${comment#[	 ]#}"
	    comment="${comment##[	 ]}"
	    subject="${comment:-"$items"}"

	    contains "$subject" "${selections[@]}" && \
		definitions+=("$line")
	fi

    done < "$definitionFilespec"
done
[ ${#definitions[@]} -eq 0 ] && exit 1



missingDefinitionCount=0
for definition in "${definitions[@]}"
do
    items="${definition%%[	 ]#*}"
    comment="${definition#"$items"}"
    comment="${comment#[	 ]#}"
    comment="${comment##[	 ]}"
    subject="${comment:-"$items"}"
    eval "set -- $items"
    itemVerb=are; [ -n "$comment" -o $# -eq 1 ] && itemVerb=is
    itemAuxVerb=

    typeset -a missingItems=()
    lastMissingItem=
    for item
    do
	case "$item" in
	    preinstall:*|postinstall:*)
		if [ -n "$lastMissingItem" ]; then
		    # The preinstall action will run when the previous item will
		    # be installed. The postinstall action will run when the
		    # installation of the previous item was successful. To be
		    # able to check that, we need that item as well, so append
		    # it on a new line.
		    missingItems+=("$item"$'\n'"$lastMissingItem")
		fi
		;;
	    *)	if hasItem "$item"; then
		    lastMissingItem=
		else
		    missingItems+=("$item")
		    lastMissingItem="$item"
		fi
		;;
	esac
    done

    if [ ${#missingItems[@]} -eq 0 ]; then
	[ "$isVerbose" ] && printf >&2 'Already installed: %s\n' "$definition"
    else
	let missingDefinitionCount+=1
	what=
	if [ $# -gt ${#missingItems[@]} ]; then
	    missingItemsPlural=s; [ ${#missingItems[@]} -eq 1 ] && missingItemsPlural=
	    what="${#missingItems[@]} item${missingItemsPlural} missing: ${missingItems[*]}"
	elif [ $# -gt 1 ]; then
	    what="all ${#missingItems[@]} items are missing"
	fi

	if [ ${#missingItems[@]} -eq 1 ] && [[ "${missingItems[0]}" =~ 'custom:false:' ]]; then
	    itemVerb='may or may'
	    itemAuxVerb=be
	fi

	if $obtainSelection --subject "$subject" --verb "$itemVerb not yet${itemAuxVerb:+ }$itemAuxVerb" --state "installed${what:+ (}${what}${what:+)}" --action 'install it'; then
	    addItems "${missingItems[@]}"
	fi
    fi
done



generateInstallCommands
printInstallCommands && exit

if [ "${#definitions[@]}" -gt 0 ]; then
    if [ $missingDefinitionCount -gt 0 ]; then
	missingDefinitionCountPlural=s; [ $missingDefinitionCount -eq 1 ] && missingDefinitionCountPlural=
	printf >&2 '%d not yet installed definition%s were declined.\n' "$missingDefinitionCount" "$missingDefinitionCountPlural"
    else
	definitionsVerb=are; definitionsPlural=s; [ ${#definitions[@]} -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	printf >&2 '%d definition%s %s already installed.\n' "${#definitions[@]}" "$definitionsPlural" "$definitionsVerb"
    fi
else
    echo >&2 'No definitions have been found.'
fi
exit 1
