#!/bin/bash
shopt -qs extglob nullglob

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
readonly projectDir="${scriptDir}/.."
baseDir="${projectDir}/etc"
typeDir="${projectDir}/lib/types"
readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"

SUDO='sudo --set-home'; [ $EUID -eq 0 ] && SUDO=''  # Use root's home; especially pip3 writes to ~/.cache/pip and complains if the files belong to another user.

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s | tee install-script.sh && sh install-script.sh\n' "$(basename "$1")" '[-v|--verbose] [-y|--yes] [-b|--batch] [-s|--select DEFINITION [-s ...]] [--base-dir BASE-DIR] [--name NAME] -a|--all|GROUP-NAME|GROUP-FILESPEC [...] [-?|-h|--help]|[-H|--config-help [TYPE]]'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '-e|--execute [...]'
    echo
    echo 'Suggestions for automation in a script:'
    echo
    printf 'Usage: packageInstallCommandLine="$(%q %s)" && eval "$packageInstallCommandLine"\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s | runWithPrompt --exit-on-failure\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '--execute --yes --batch [--select DEFINITION] [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Guided wizard to interactively choose / take (with -y|--yes) (from DEFINITION(s)
/ all / the passed GROUP(s)) and install various common software that I use.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --config-help|-H [TYPE]
			Show details about the configuration syntax for all /
			for TYPE.
    --execute|-e	Directly execute the installation commands (as long as
			they succeed; like with set -e) instead of just printing
			them.
    --verbose|-v	Also mention already installed definitions that are
			skipped.
    --yes|-y		Accept all definitions (that are not yet installed and
			have been chosen) without the usual interactive query.
    --batch|-b		Skip any interactive user confirmation for installation
			commands (e.g. by the package manager).
    --select|-s	DEFINITION
			Choose DEFINITION, which must exactly match the COMMENT
			in a definition if one exists or the exact list of ITEMs
			(with definitions broken over multiple lines already
			joined), instead of considering all from the passed
			GROUP(s).
    --base-dir BASE-DIR Consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR instead of
			using those bundled with this project.
    --add-base-dir BASE-DIR
			Also consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR (with
			higher preference than those bundled with this project).
    --name NAME		Use NAME for storing the user's choices.
    --all|-a		Consider definitions from all existing definition
			groups.
    GROUP-NAME		Consider definitions from GROUP-NAME, as stored inside
			this project / BASE-DIR.
    GROUP-FILESPEC	Consider definitions from GROUP-FILESPEC, which can
			point to anywhere in the file system.
HELPTEXT
}


highlightPrefix()
{
    local sedPrefixHighlighting; [ ${#pager[@]} -gt 0 ] && sedPrefixHighlighting='1s/^\([^:]\+:\)/[01m&[0m/'
    sed -e "$sedPrefixHighlighting"
}
printConfigUsageForTypes()
{
    local padding=
    local prefix; for prefix
    do
	local typeFunction="${typeRegistry["${prefix:-native}:"]}"
	local definitionFilterFunction="${definitionFilterTypeRegistry["${prefix}:"]}"
	if [ -n "$typeFunction" ]; then
	    printf "$padding"
	    eval "configUsage${typeFunction}" | highlightPrefix
	elif [ -n "$definitionFilterFunction" ]; then
	    printf "$padding"
	    eval "configUsage${definitionFilterFunction}" | highlightPrefix
	elif [ "$prefix" = preinstall ]; then
	    printf "$padding"
	    configUsagePreinstall | highlightPrefix
	elif [ "$prefix" = postinstall ]; then
	    printf "$padding"
	    configUsagePostinstall | highlightPrefix
	elif [ "$prefix" = postinstall-or-once ]; then
	    printf "$padding"
	    configUsagePostinstall | highlightPrefix
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	padding=$'\n'
    done
}
printConfigUsage()
{
    if [ $# -eq 0 ]; then
	cat <<'HELPTEXT'
A definition consists of one or many whitespace-separated ITEMs, optionally
followed by a # DESCRIPTION. It can be broken over multiple lines, with a
trailing \ as the line continuation character. Each ITEM may have implicit pre-
and post-install steps in ./etc/{pre,post}install/ITEM/*, allowing for
customization around their installation no matter in which definition ITEM has
been selected.
Definitions are grouped into DEFINITION-GROUPs which contain definitions that
belong to a certain category or are typically installed together for a certain
use case.
HELPTEXT
	echo
	typeset -a typeOrdering=("${!typeInstallOrder[@]}")
	readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

	typeset -A mirroredTypeRegistry=()
	for prefix in "${!typeRegistry[@]}"
	do
	    mirroredTypeRegistry["${typeRegistry["$prefix"]}"]="$prefix"
	done

	typeset -a prefixes=()
	local order; for order in "${typeOrdering[@]}"
	do
	    prefixes+=("${mirroredTypeRegistry["${typeInstallOrder["$order"]}"]}")
	done
	typeset -a definitionFilterPrefixes=("${!definitionFilterTypeRegistry[@]}")

	printConfigUsageForTypes "${prefixes[@]%:}" "${definitionFilterPrefixes[@]%:}"    # Show config help for all types (in the order in which the types are also installed).

	echo
	configUsagePreinstall | highlightPrefix
	echo
	configUsagePostinstall | highlightPrefix
	echo
	configUsagePostinstallOrOnce | highlightPrefix
    else
	printConfigUsageForTypes "$@"
    fi
}

typeset -a nativeRegistry=()
typeset -A typeRegistry=([native:]=Native)
typeset -A typeInstallOrder=([100]=Native)
typeset -A definitionFilterTypeRegistry=()
for typeLib in "${typeDir}"/*.sh
do
    source "$typeLib" || exit $?
done
set -o noglob

typeset -a acceptedGroups=()
addAllAcceptedGroups()
{
    typeset -a groups=()
    readarray -t groups < <(cd "${definitionDirspecs[0]}" && find . -print | sort | sed -e 's#^\./##')
    typeset -a filteredGroups=()
    local group; for group in "${groups[@]}"
    do
	contains "$group" "${filteredGroups[@]}" && continue

	if [ -d "${definitionDirspecs[0]}/${group}" ]; then
	    groupDirectoryGroupCount=$(countGlob "${group}/*" "${groups[@]}")
	    [ $groupDirectoryGroupCount -gt 1 ] || continue  # Ignore a group directory that has only one group in it; the query for the group itself will suffice.
	    memoizeDecision --memoize-group "${setupName}-groups" --subject "$group" --verb "directory (with $groupDirectoryGroupCount groups) is not" --state 'chosen' --action 'consider it' || \
		readarray -O ${#filteredGroups[@]} -t filteredGroups < <(filterGlob "${group}/*" "${groups[@]}")
	    continue
	fi

	memoizeDecision --memoize-group "${setupName}-groups" --subject "$group" --verb 'is not' --state 'chosen' --action 'consider it' && \
	    acceptedGroups+=("$group")
    done
}

database()
{
    picoDB --base-type data --namespace "$setupName" --table "$@"
}

onceMarker()
{
    executionMarker --base-type data --namespace "$setupName" --group postinstall-or-once "$@"
}

case ${#nativeRegistry[@]} in
    0)	echo >&2 'ERROR: No native package management found.'; exit 3;;
    1)	readonly nativePackageManager="${nativeRegistry[0]}";;
    *)	printf >&2 'ERROR: Multiple native package managers found: %s\n' "$(joinBy ', ' "${nativeRegistry[@]}")"; exit 3;;
esac
hasNative()
{
    has$nativePackageManager "$@"
}
addNative()
{
    add$nativePackageManager "$@"
}

configUsageNative()
{
    # Note: Do not delegate to configUsage$nativePackageManager().
    cat <<HELPTEXT
Items without a prefix refer to packages installed via the distribution's
package manager (${nativePackageManager,}).
HELPTEXT
}
configUsagePreinstall()
{
    cat <<'HELPTEXT'
preinstall: items consist of an ACTION that is one of the following:
- an executable command (potentially followed by command-line arguments) in the
  ./etc/preinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the preinstallation steps
- a text file in the ./etc/preinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual pre-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a PREINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A preinstall item runs (before other installation actions) if the
non-pre/postinstall item preceding it in the current definition is missing, but
the definition has now been selected.
HELPTEXT
}
configUsagePostinstall()
{
    cat <<'HELPTEXT'
postinstall: items consist of an ACTION that is one of the following:
- an executable command (potentially followed by command-line arguments) in the
  ./etc/postinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the postinstallation steps
- a text file in the ./etc/postinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual post-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a POSTINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A postinstall item runs if the non-pre/postinstall item preceding it in the
current definition was missing, but has been successfully installed by the
installation commands.
HELPTEXT
}
configUsagePostinstallOrOnce()
{
    cat <<'HELPTEXT'
postinstall-or-once: items consist of [ID:]ACTION where the latter is one of the
following:
- an executable command (potentially followed by command-line arguments) in the
  ./etc/postinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the postinstallation steps
- a text file in the ./etc/postinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual post-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a POSTINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
Like a postinstall item, a postinstall-or-once item runs if the
non-pre/postinstall item preceding it in the current definition was missing, but
has been successfully installed by the installation commands. Additionally, if
the non-pre/postinstall item preceding it already existed (e.g. it comes
preinstalled), it will also run once (until it succeeds); ID or ACTION itself is
used for that uniqueness check.
HELPTEXT
}

typeset -a addedPreinstallArgs=()
addPreinstall()
{
    local name="${1:?}"; shift
    if [ "${addedItems["${name#*$'\n'}"]}" ]; then
	# Convert the "preinstall:ACTION\nITEM" to --pre "$ITEM" --action
	# "$ACTION" and do a recursive invocation now, in order to print the
	# preinstallation commands before anything else. This cannot be done
	# within this script's scope, as preinstall items that reference another
	# ITEM will populate all the addedITEM* arrays, and everything will be
	# intermingled and later printed type by type in the static order, but
	# the purpose of preinstall is to execute stuff before anything else.
	addedPreinstallArgs+=(--pre "${name#*$'\n'}" --action "${name%%$'\n'*}")
    fi
}
preinstallHook()
{
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && addedPreinstallArgs+=(--pre "$name" --action "${actionScript#"${dirspec}/"}")
	    done
	done
    set -o noglob
}
typeset -a addedPostinstallArgs=()
addPostinstall()
{
    local name="${1:?}"; shift
    local recursiveCallArg="$1"; shift

    # Convert the "postinstall:ACTION\nITEM" to
    # --post "$ITEM" --action "$ACTION".
    addedPostinstallArgs+=("${recursiveCallArg:---post}" "${name#*$'\n'}" --action "${name%%$'\n'*}" "$@")
}
postinstallHook()
{
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && addedPostinstallArgs+=(--post "$name" --action "${actionScript#"${dirspec}/"}")
	    done
	done
    set -o noglob
}

hasItem()
{
    local item="${1:?}"; shift
    local name="${item#*:}"
    local prefix="${item%"$name"}"

    local typeFunction="${typeRegistry["${prefix:-native:}"]}"
    if [ -n "$typeFunction" ]; then
	eval "has${typeFunction} \"\$name\""
    else
	printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	exit 3
    fi
}

askTo()
{
    memoizeDecision --memoize-group "$setupName" "$@"
}
askToInstall()
{
    $obtainSelection --subject "${1:?}" --verb 'is not yet' --state installed --action 'install it'
}

isAvailableNative()
{
    isAvailable$nativePackageManager "$@"
}
isAvailableOrUserAcceptsNative()
{
    local isPreinstall; if [ "$1" = --preinstall ]; then shift; isPreinstall=t; fi
    local packageManagerExecutable="${1:?}"; shift
    local packageManagerPackageName="${1:-$packageManagerExecutable}"; shift
    local packageManagerSubject="${1:-$packageManagerPackageName}"; shift

    if isAvailableNative "$packageManagerPackageName" || exists "$packageManagerExecutable"; then
	return
    fi

    if askToInstall "$packageManagerSubject"; then
	if [ "$isPreinstall" ]; then
	    addPreinstall "native:${packageManagerPackageName}"$'\nppa'	# ppa is a dummy ITEM that is ignored for preinstall actions, anyway.
	else
	    addNative "$packageManagerPackageName"
	fi
    else
	return 1
    fi
}
typeset -A addedItems=()
addItems()
{
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	local typeFunction="${typeRegistry["${prefix:-native:}"]}"
	if [ -n "$typeFunction" ]; then
	    eval "add${typeFunction} \"\$name\""
	elif [ "$prefix" = preinstall: ]; then
	    addPreinstall "$name"
	elif [ "$prefix" = postinstall: ]; then
	    addPostinstall "$name"
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	addedItems["$item"]=t	# Record all added items for the preinstall check.
    done
}
hasOrAddItems()
{
    typeset -a missingItems=()
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	if contains "$prefix" "${!definitionFilterTypeRegistry[@]}" preinstall: postinstall: postinstall-or-once:; then
	    printf >&2 'ERROR: Cannot use a %s type within a preinstall / postinstall[-or-once] item.\n' "$prefix"
	    exit 3
	fi

	hasItem "$item"
	case $? in
	    0)	;;
	    98)	;;
	    99)	;;
	    *) missingItems+=("$item");;
	esac
    done

    [ ${#missingItems[@]} -eq 0 ] && return 1
    addItems "${missingItems[@]}"
}


installNative()
{
    # Do not invoke install$nativePackageManager(); as native types are
    # registered separately, their install function is invoked anyway, and that
    # will then process both native and prefixed items together.
    :
}

preInstall()
{
    [ ${#addedPreinstallArgs[@]} -gt 0 ] || return

    "${scriptDir}/${scriptName}" "${recursiveArgs[@]}" "${addedPreinstallArgs[@]}"
}
getPreinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local preinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
    do
	local preinstallFilespec="${dirspec}/${preinstallAction}"
	if [ $compareOp "$preinstallFilespec" ]; then
	    printf %s "$preinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPreInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift

    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if actionFilespec="$(getPreinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	actionWithoutSudo="${actionFilespec}/${actionWithoutSudo#"$actionWithoutSudoAndArgs"}"
	addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
    elif actionFilespec="$(getPreinstallFilespec -e "${action}")"; then
	local quotedPreinstallNotification; printf -v quotedPreinstallNotification %s "$actionFilespec"
	addUniqueToBeInstalledCommand "addLoginNotification --file $quotedPreinstallNotification --immediate --no-blocking-gui"
    else
	local name="${action#*:}"
	local prefix="${action%"$name"}"
	if [ "$prefix" = native: ]; then
	    # Note: Native packages would be indistinguishable from the
	    # PREINSTALL-EXPRESSION, as they have no prefix. Allow using a
	    # special "native:" prefix should it be necessary to install a
	    # package via the distribution's package manager before the main
	    # installation.
	    hasOrAddItems "${action#native:}"
	elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
	    hasOrAddItems "$action"
	else
	    addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
	fi
    fi || printf >&2 'Skipping preinstall action, because %s indicated that no action is needed.\n' "$action"
}

postInstall()
{
    [ ${#addedPostinstallArgs[@]} -gt 0 ] || return

    typeset -a executeArg=(); [ "$isExecute" ] || executeArg=(--execute)    # Directly execute any postinstall commands; these already were authorized by the user when they executed the recursive script invocation. It's cumbersome when the execution just prints yet another command-line to be captured and executed, and especially when an automatic capture and execution is used (redirection into a file, into the bag, etc.), this printing then happens outside of the capture.
    local quotedPostInstallCommand
    printf -v quotedPostInstallCommand '%q ' "${scriptDir}/${scriptName}" "${executeArg[@]}" "${recursiveArgs[@]}" "${addedPostinstallArgs[@]}"
    addUniqueToBeInstalledCommand "${quotedPostInstallCommand% }"
}
getPostinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local postinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
    do
	local postinstallFilespec="${dirspec}/${postinstallAction}"
	if [ $compareOp "$postinstallFilespec" ]; then
	    printf %s "$postinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPostInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift
    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if hasItem "$item"; then
	if actionFilespec="$(getPostinstallFilespec -x "${action}")"; then
	    "$actionFilespec"
	elif actionFilespec="$(getPostinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	    local actionArgs="${actionWithoutSudo#"${actionWithoutSudoAndArgs}"}"
	    ${sudoPrefix:+$SUDO} "$actionFilespec" $actionArgs
	elif actionFilespec="$(getPostinstallFilespec -e "${action}")"; then
	    addLoginNotification --file "$actionFilespec" --immediate
	else
	    local name="${action#*:}"
	    local prefix="${action%"$name"}"
	    if [ "$prefix" = native: ]; then
		# Note: Native packages would be indistinguishable from the
		# POSTINSTALL-EXPRESSION, as they have no prefix. Allow using a
		# special "native:" prefix should it be necessary to install a
		# package via the distribution's package manager after a
		# successful installation.
		hasOrAddItems "${action#native:}" && \
		    generateInstallCommands
		printInstallCommands || \
		    printf >&2 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
		hasOrAddItems "$action" && \
		    generateInstallCommands
		printInstallCommands || \
		    printf >&2 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    else
		eval "$action"
	    fi
	fi || return 1
    else
	printf >&2 'Skipping postinstall action, because installation of %s was not successful.\n' "$item"
    fi
}

typeset -a toBeInstalledCommands=()
addUniqueToBeInstalledCommand()
{
    local command="${1:?}"; shift
    contains "$command" "${toBeInstalledCommands[@]}" && return 1
    toBeInstalledCommands+=("$command")
}
generateInstallCommands()
{
    preInstall

	typeset -a typeOrdering=("${!typeInstallOrder[@]}")
	readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

	local order; for order in "${typeOrdering[@]}"
	do
	    local typeFunction="${typeInstallOrder["$order"]}"
	    eval "install${typeFunction}"
	done

    postInstall
}
printInstallCommands()
{
    [ ${#toBeInstalledCommands[@]} -eq 0 ] && return 1

    if [ "$isExecute" ]; then
	local installCommandline="$(joinBy '; ' "${toBeInstalledCommands[@]}")"
	set -e
	eval "$installCommandline"
	exit $?	# Exit the script now because else installation failure would be treated as if there were no installation commands.
    else
	printf '%s\n' "${toBeInstalledCommands[@]}"
    fi
}
generateAndPrintInstallCommands()
{
    generateInstallCommands
    printInstallCommands
}


setupName=
obtainSelection=askTo
isAddAll=
typeset -a selections=()
typeset -a specialHandlingCommands=()
specialHandlingFinalCommand=
isBatch=
isExecute=
isVerbose=
typeset -a recursiveArgs=()
typeset -a additionalBaseDirs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--config-help|-H)
			shift
			typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
			eval 'printConfigUsage "$@"' "${pager:+|}" '"${pager[@]}"'
			exit 0
			;;
	--base-dir)	recursiveArgs+=("$1" "$2"); shift; baseDir="${1:?}"; shift;;
	--add-base-dir)	recursiveArgs+=("$1" "$2"); shift; additionalBaseDirs=("${1:?}" "${additionalBaseDirs[@]}"); shift;;
	--execute|-e)	recursiveArgs+=("$1"); shift; isExecute=t;;
	--verbose|-v)	recursiveArgs+=("$1"); shift; isVerbose=t;;
	--yes|-y)	shift; obtainSelection=true;;
	--batch|-b)	shift; isBatch=t;;
	--select|-s)	shift; selections+=("$1"); shift;;
	--all|-a)	shift; isAddAll=t;;
	--name)		shift; setupName="${1:?}"; shift;;
	--database)	shift; database "$@"; exit $?;;
	--pre)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --pre %q.\n' "$item"; exit 3
			fi
			shift; action="$1"; shift
			printf -v specialCommand 'runPreInstallCheck %q %q' "$item" "$action"
			specialHandlingCommands+=("$specialCommand")
			specialHandlingFinalCommand='generateAndPrintInstallCommands'
			;;
	--post)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post %q.\n' "$item"; exit 3
			fi
			shift; action="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q' "$item" "$action"
			specialHandlingCommands+=("${specialCommand% }")
			;;
	--post-or-once)	shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; action="$1"; shift
			if [ "$1" != '--id' ]; then
			    printf >&2 'ASSERT: No --id following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; id="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q && onceMarker --update %q' "$item" "$action" "$id"
			specialHandlingCommands+=("${specialCommand% }")
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
typeset -a customActionsDirspecs=()
typeset -a requireActionsDirspecs=()
typeset -a preinstallActionsDirspecs=()
typeset -a postinstallActionsDirspecs=()
typeset -a definitionDirspecs=()

for dirspec in "${additionalBaseDirs[@]}" "$baseDir"
do
    [ -d "${dirspec}/custom" ]      && customActionsDirspecs+=("${dirspec}/custom")
    [ -d "${dirspec}/require" ]     && requireActionsDirspecs+=("${dirspec}/require")
    [ -d "${dirspec}/preinstall" ]  && preinstallActionsDirspecs+=("${dirspec}/preinstall")
    [ -d "${dirspec}/postinstall" ] && postinstallActionsDirspecs+=("${dirspec}/postinstall")
    [ -d "${dirspec}/definitions" ] && definitionDirspecs+=("${dirspec}/definitions")
done
if [ -z "$setupName" ]; then
    setupName="$(basename -- "$(dirname -- "$(simplifyPath "$baseDir")")")"
    setupName="setup-${setupName#setup-}"
fi

if [ "$isAddAll" ]; then
    addAllAcceptedGroups
    if [ ${#acceptedGroups[@]} -eq 0 ]; then
	exit 1
    else
	set -- "${acceptedGroups[@]}" "$@"

	acceptedGroupsPlural=s; [ ${#acceptedGroups[@]} -eq 1 ] && acceptedGroupsPlural=
	printf >&2 '\nOkay, %d definition group%s selected. Now for the definitions themselves:\n\n' "${#acceptedGroups[@]}" "$acceptedGroupsPlural"
    fi
fi
if [ ${#specialHandlingCommands[@]} -gt 0 ]; then
    status=0
    for specialCommand in "${specialHandlingCommands[@]}"
    do
	eval "$specialCommand" || status=1
    done
    eval "$specialHandlingFinalCommand" || status=1
    exit $status
elif [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

IFS=' '
typeset -a definitions=()
for definitionFile
do
    if [ -f "${definitionDirspecs[0]}/${definitionFile}" -a "${definitionFile:0:1}" != '.' ]; then
	definitionFilespec="${definitionDirspecs[0]}/${definitionFile}"
    elif [ -f "${definitionFile}" ]; then
	definitionFilespec="$definitionFile"
    else
	printf >&2 'ERROR: Definition "%s" does not exist.\n' "$definitionFile"
	exit 2
    fi

    while IFS=$'\n' read -r line
    do
	while [[ "$line" =~ \\$ ]]
	do
	    IFS=$'\n' read -r nextLine
	    line="${line%\\}$nextLine"
	done
	[[ "$line" =~ ^[[:space:]]*# ]] && continue
	[[ "$line" =~ ^[[:space:]]*$ ]] && continue


	if [ ${#selections[@]} -eq 0 ]; then
	    definitions+=("$line")
	else
	    items="${line%%[	 ]#*}"
	    comment="${line#"$items"}"
	    comment="${comment##+([	 ])#*([	 ])}"
	    subject="${comment:-"$items"}"

	    contains "$subject" "${selections[@]}" && \
		definitions+=("$line")
	fi

    done < "$definitionFilespec"
done
[ ${#definitions[@]} -eq 0 ] && exit 1



missingDefinitionCount=0
for definition in "${definitions[@]}"
do
    items="${definition%%[	 ]#*}"
    comment="${definition#"$items"}"
    comment="${comment#[	 ]#}"
    comment="${comment##[	 ]}"
    subject="${comment:-"$items"}"
    eval "set -- $items"
    itemVerb=are; [ -n "$comment" -o $# -eq 1 ] && itemVerb=is
    itemAuxVerb=

    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	[ -n "$prefix" ] || continue
	definitionFilterFunction="${definitionFilterTypeRegistry["$prefix"]}"
	if [ -n "$definitionFilterFunction" ]; then
	    eval "isDefinitionAcceptedBy${definitionFilterFunction} \"\$name\" \"\$definition\"" || \
		continue 2
	fi
    done

    typeset -a missingItems=()
    lastRealItem=
    lastMissingItem=
    let realItemCnt=0
    let missingRealItemCnt=0
    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	if contains "$prefix" "${!definitionFilterTypeRegistry[@]}"; then
	    continue    # Ignore; definition filters have already been handled.
	elif contains "$prefix" preinstall: postinstall:; then
	    if [ -z "$lastRealItem" ]; then
		printf >&2 'ERROR: No previous item before %s.\n' "$item"
		exit 3
	    elif [ "$lastRealItem" = "$lastMissingItem" ]; then
		# The preinstall action will run when the previous item will
		# be installed. The postinstall action will run when the
		# installation of the previous item was successful. To be
		# able to check that, we need that item as well, so append
		# it on a new line.
		missingItems+=("$item"$'\n'"$lastMissingItem")
	    fi
	elif [ "$prefix" = postinstall-or-once: ]; then
	    if [ -z "$lastRealItem" ]; then
		printf >&2 'ERROR: No previous item before %s.\n' "$item"
		exit 3
	    else
		hasItem "$lastRealItem"
		case $? in
		    0)	rest="${name#*:}"
			id="${name%"$rest"}"; id="${id%:}"; id="${id:-$rest}"
			escapedId="${id//	/ }"
			onceMarker --query "$escapedId"
			case $? in
			    0)	;;  # The item already is installed, and the check has been run already.
			    1)	# The item already is installed, but the check did not run yet.
				addPostinstall "$rest"$'\n'"$lastRealItem" --post-or-once --id "$escapedId"
				;;
			    *)	exit 3;;
			esac
			;;
		    98)	;;
		    99)	;;
		    *)	if [ -n "$lastMissingItem" ]; then
			    # The postinstall action will run when the installation of the
			    # previous item was successful. To be able to check that, we
			    # need that item as well, so append it on a new line.
			    missingItems+=("postinstall:${name}"$'\n'"$lastMissingItem")
			fi
			;;
		esac
	    fi
	else
	    lastRealItem="$item"
	    hasItem "$item"
	    case $? in
		0)  lastMissingItem=;;
		98) continue;;	# Just skip this item.
		99) break;;	# If one item's state cannot not be determined, the entire definition should be skipped, as we cannot ensure the correct installation.
		*)  missingItems+=("$item")
		    lastMissingItem="$item"
		    let missingRealItemCnt+=1
		    ;;
	    esac
	    let realItemCnt+=1
	fi
    done

    if [ ${#missingItems[@]} -eq 0 ]; then
	[ "$isVerbose" ] && printf >&2 'Already installed: %s\n' "$definition"
    else
	let missingDefinitionCount+=1
	what=
	if [ $realItemCnt -gt $missingRealItemCnt ]; then
	    missingItemsPlural=s; [ $missingRealItemCnt -eq 1 ] && missingItemsPlural=
	    what="$missingRealItemCnt item${missingItemsPlural} missing: ${missingItems[*]}"
	elif [ $realItemCnt -gt 1 ]; then
	    what="all $missingRealItemCnt items are missing"
	fi

	if [ $missingRealItemCnt -eq 1 ] && [[ "${missingItems[0]}" =~ 'custom:false:' ]]; then
	    itemVerb='may or may'
	    itemAuxVerb=be
	fi

	if $obtainSelection --subject "$subject" --verb "$itemVerb not yet${itemAuxVerb:+ }$itemAuxVerb" --state "installed${what:+ (}${what}${what:+)}" --action 'install it'; then
	    addItems "${missingItems[@]}"
	fi
    fi
done



generateAndPrintInstallCommands && exit

if [ "${#definitions[@]}" -gt 0 ]; then
    if [ $missingDefinitionCount -gt 0 ]; then
	missingDefinitionCountPlural=s; missingDefinitionCountAuxilliaryVerb=were; [ $missingDefinitionCount -eq 1 ] && { missingDefinitionCountPlural=; missingDefinitionCountAuxilliaryVerb=was; }
	printf >&2 '%d not yet installed definition%s %s declined.\n' "$missingDefinitionCount" "$missingDefinitionCountPlural" "$missingDefinitionCountAuxilliaryVerb"
    else
	definitionsVerb=are; definitionsPlural=s; [ ${#definitions[@]} -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	printf >&2 '%d definition%s %s already installed.\n' "${#definitions[@]}" "$definitionsPlural" "$definitionsVerb"
    fi
else
    echo >&2 'No definitions have been found.'
fi
exit 1
