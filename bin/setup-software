#!/bin/bash
shopt -qs extglob nullglob

: ${SETUPSOFTWARE_GROUP_VALID_TIMESPAN:=1d}
: ${SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN:=1d}
readonly GROUPDIR_FILTER_FILENAME='.groupdir-filter'

readonly scriptDir="$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)"
[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
readonly projectDir="${scriptDir}/.."
baseDir="${projectDir}/etc"
typeDir="${projectDir}/lib/types"
readonly scriptName="$(basename -- "${BASH_SOURCE[0]}")"

SUDO='sudo --set-home'; [ $EUID -eq 0 ] && SUDO=''  # Use root's home; especially pip3 writes to ~/.cache/pip and complains if the files belong to another user.

printShortUsage()
{
    local commandLineOptionExtensions; [ ${#commandLineOptions[@]} -gt 0 ] && commandLineOptionExtensions="$(joinBy --prefix '[' --suffix ']' '] [' "${!commandLineOptions[@]}")"
    local commandLineParameterExtensions; [ ${#commandLineParameters[@]} -gt 0 ] && commandLineParameterExtensions="$(joinBy --prefix '[' --suffix ' ARG]' ' ARG] [' "${!commandLineParameters[@]}")"

    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '--clear-group-recall|--clear-definition-recall | -?|-h|--help | -H|--config-help [TYPE]'
    echo
    printf 'Usage: %q %s | tee install-script.sh && sh install-script.sh\n' "$(basename "$1")" "[--check|--dry-run] [-q|--quiet|--silence-no-definitions|-v|--verbose] [-f|--force] [-y|--yes|--recall-only] [-b|--batch] [-s|--select DEFINITION [-s ...]] [--base-dir BASE-DIR] [--name NAME]${commandLineOptionExtensions:+ }${commandLineOptionExtensions}${commandLineParameterExtensions:+ }${commandLineParameterExtensions} -a|--all|--group-recall-only|GROUP-NAME|GROUP-FILESPEC [...]"
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '-p|--print|-e|--execute [...]'
    echo
    echo 'Suggestions for automation in a script:'
    echo
    printf 'Usage: packageInstallCommandLine="$(%q %s)" && eval "$packageInstallCommandLine"\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s | runWithPrompt --exit-on-failure\n' "$(basename "$1")" '--yes --batch [--select DEFINITION] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '--execute --yes --batch [--select DEFINITION] [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'
    echo
    echo 'Recursive use:'
    echo
    printf "custom:'& --check --yes [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)':'%q --yes\${isBatch:+ --batch}\${isQuiet:+ --quiet}\${isVerbose:+ --verbose} [--add-base-dir BASE-DIR] (--base-dir BASE-DIR -a|--all|GROUP-NAME | GROUP-FILESPEC)'" "$(basename "$1")"
    echo
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    local IFS=$'\n'
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Guided wizard to interactively choose / take (with -y|--yes) (from DEFINITION(s)
/ all / the passed GROUP(s)) and [print commands to] install those selected
software items (from various sources).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --config-help|-H [TYPE]
			Show details about the configuration syntax for all /
			for TYPE.
    --check		Just check whether any installation would happen;
			succeed if nothing is chosen / all is up-to-date, fail
			if some installation action would be required.
    --dry-run		Like --check, but behave like usual (success means some
			installation action would be required; failure means
			not), and also print related messages; just omit the
			installation commands.
    --print|-p		Just print the installation commands to standard output;
			by default, the command will balk when output is to the
			terminal, as it is supposed to be captured and executed.
    --execute|-e	Directly execute the installation commands (as long as
			they succeed; like with set -e) instead of just printing
			them.
    --quiet|-q		Suppress any informational user messages except errors
			and the querying itself. If this is passed before
			--[group-]recall-only, those messages will be silenced
			as well.
    --silence-no-definitions
			Do not print the message that no definitions have been
			found.
    --verbose|-v	Also mention already installed definitions that are
			skipped.
    --force|-f		Assume that nothing is already installed / all checks
			fail and always execute all installation actions.
			Definition filters still apply. It's recommended to
			limit the scope to a single GROUP or even DEFINITION via
			--select.
    --yes|-y		Accept all definitions (that are not yet installed and
			have been chosen) without the usual interactive query.
    --recall-only	Only reconsider those definitions that are not yet
			installed but had been persistently accepted beforehand.
			Useful to rerun a setup to catch those definitions that
			failed to install the first time.
    --batch|-b		Skip any interactive user confirmation for installation
			commands (e.g. by the package manager).
    --select|-s	DEFINITION
			Choose DEFINITION, which must exactly match the COMMENT
			in a definition if one exists or the exact list of ITEMs
			(with definitions broken over multiple lines already
			joined), instead of considering all from the passed
			GROUP(s).
    --base-dir BASE-DIR Consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR instead of
			using those bundled with this project.
    --add-base-dir BASE-DIR
			Also consider definitions, custom actions, requirements,
			pre-, and post-install actions from BASE-DIR (with
			higher preference than those bundled with this project).
    --name NAME		Use NAME for storing the user's choices.
    --all|-a		Consider definitions from all existing definition
			groups.
    --group-recall-only	Only reconsider those definition groups that had been
			persistently accepted when executed with --all.
			Useful to rerun a setup to catch those definitions that
			failed to install the first time.
    --clear-group-recall
			Forget any persisted definition group choices made in
			previous invocations, and re-query all existing groups
			again.
    --clear-definition-recall
			Forget any persisted definition choices made in previous
			invocations, and re-query all definitions again.
    GROUP-NAME		Consider definitions from GROUP-NAME, as stored inside
			this project / BASE-DIR.
    GROUP-FILESPEC	Consider definitions from GROUP-FILESPEC, which can
			point to anywhere in the file system.
${commandLineHelpExtensions[*]}
EXIT STATUS:
    0	Complete success.
    1	Failed to install (especially failure in pre- or postinstall actions).
    2	Bad invocation, wrong or missing command-line arguments.
    3	Invalid definition syntax, internal error or failed assertion.
    4	All definition(s) [groups] were declined or already installed.
    99	No definitions have been found.
HELPTEXT
}


highlightPrefix()
{
    local sedPrefixHighlighting; [ ${#pager[@]} -gt 0 ] && sedPrefixHighlighting='1s/^\([^:]\+:\)/[01m&[0m/'
    sed -e "$sedPrefixHighlighting"
}
printConfigUsageForTypes()
{
    local padding=
    local prefix; for prefix
    do
	local typeFunction="${typeRegistry["${prefix:-native}:"]}"
	local definitionFilterFunction="${definitionFilterTypeRegistry["${prefix}:"]}"
	local definitionGroupFilterFunction="${definitionGroupFilterTypeRegistry["${prefix}:"]}"
	if [ -n "$typeFunction" ]; then
	    printf "$padding"
	    "configUsage${typeFunction}" | highlightPrefix
	elif [ -n "$definitionFilterFunction" ]; then
	    printf "$padding"
	    "configUsage${definitionFilterFunction}" | highlightPrefix
	elif [ -n "$definitionGroupFilterFunction" ]; then
	    printf "$padding"
	    "configUsage${definitionGroupFilterFunction}" | highlightPrefix
	elif [ "$prefix" = config ]; then
	    printf "$padding"
	    configUsageConfig | highlightPrefix
	elif [ "$prefix" = decorate ]; then
	    printf "$padding"
	    configUsageDecorate | highlightPrefix
	elif [ "$prefix" = preinstall ]; then
	    printf "$padding"
	    configUsagePreinstall | highlightPrefix
	elif [ "$prefix" = postinstall ]; then
	    printf "$padding"
	    configUsagePostinstall | highlightPrefix
	elif [ "$prefix" = postinstall-or-once ]; then
	    printf "$padding"
	    configUsagePostinstall | highlightPrefix
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	padding=$'\n'
    done
}
printConfigUsage()
{
    if [ $# -eq 0 ]; then
	cat <<HELPTEXT
A definition consists of one or many whitespace-separated ITEMs, optionally
followed by a # DESCRIPTION. It can be broken over multiple lines, with a
trailing \\ as the line continuation character. Each ITEM may have implicit pre-
and post-install steps in ./etc/{pre,post}install/ITEM/*, allowing for
customization around their installation no matter in which definition ITEM has
been selected.
Definitions are grouped into DEFINITION-GROUPs which contain definitions that
belong to a certain category or are typically installed together for a certain
use case.
Definition groups can be excluded from consideration, either completely or
starting from a certain line, through definition group filters. These work like
definition filters, but the entire definition has to consist of them (no mixing
with other items).
Multiple definition group filters within one line are OR-ed together; if at
least one passes, reading of definitions continues. To require the passing of
all definition group filters (logical AND), put them on subsequent lines.
If a complete definition group is excluded, it won't be offered by --all,
neither. To exclude a complete subdirectory of definition groups, you can put a
DEFINITION-GROUP-DIR/${GROUPDIR_FILTER_FILENAME} file in there; it has to start
with the definition group filter(s) and then must be followed by a regular dummy
definition (e.g. simply a line containing "dummy:"). If it is completely empty,
the whole subdirectory will be filtered unconditionally.
HELPTEXT
	echo
	typeset -a typeOrdering=("${!typeInstallOrder[@]}")
	readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

	typeset -A mirroredTypeRegistry=()
	for prefix in "${!typeRegistry[@]}"
	do
	    mirroredTypeRegistry["${typeRegistry["$prefix"]}"]="$prefix"
	done

	typeset -a prefixes=()
	local order; for order in "${typeOrdering[@]}"
	do
	    prefixes+=("${mirroredTypeRegistry["${typeInstallOrder["$order"]}"]}")
	done
	typeset -a definitionFilterPrefixes=("${!definitionFilterTypeRegistry[@]}")
	typeset -a definitionGroupFilterPrefixes=("${!definitionGroupFilterTypeRegistry[@]}")

	printConfigUsageForTypes "${prefixes[@]%:}" "${definitionFilterPrefixes[@]%:}" "${definitionGroupFilterPrefixes[@]%:}"    # Show config help for all types (in the order in which the types are also installed).

	echo
	configUsageConfig | highlightPrefix
	echo
	configUsageDecorate | highlightPrefix
	echo
	configUsagePreinstall | highlightPrefix
	echo
	configUsagePostinstall | highlightPrefix
	echo
	configUsagePostinstallOrOnce | highlightPrefix
    else
	printConfigUsageForTypes "$@"
    fi
}

# Make this available already before sourcing the type libraries so that types
# can use it for a guard whether the base application is installed
# (e.g. if ! exists firefox || ! hasNative firefox; then ...)
# Native type libraries start with 00*.sh so that they are loaded first.

typeset -a commandLineHelpExtensions=()
typeset -A commandLineOptions=()
typeset -A commandLineParameters=()

typeset -a nativeRegistry=()
typeset -A typeRegistry=([native:]=Native)
typeset -A typeInstallOrder=([100]=Native)
typeset -A definitionFilterTypeRegistry=()
typeset -A definitionGroupFilterTypeRegistry=()

hasNative()
{
    [ ${#nativeRegistry[@]} -gt 0 ] && has${nativeRegistry[0]} "$@"
}
addNative()
{
    add$nativePackageManager "$@"
}

messagePrintf()
{
    [ "$isQuiet" ] && return
    printf >&2 "$@"
}

silentRecallDecision()
{
    recallDecision >/dev/null 2>&1 "$@"
}

getSubjectFromItems()
{
    typeset -a typeItems=()
    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	[ -n "${typeRegistry["${prefix:-native:}"]}" ] && \
	    typeItems+=("$item")
    done
    [ ${#typeItems[@]} -eq 0 ] && typeItems=("$@")

    joinBy ' ' "${typeItems[@]}"
}

getDefinitionGroupFilespec()
{
    local definitionGroup="${1:?}"; shift
    local dirspec; for dirspec in "${definitionDirspecs[@]}"
    do
	local definitionGroupFilespec="${dirspec}/${definitionGroup}"
	if [ -f "$definitionGroupFilespec" ]; then
	    printf %s "$definitionGroupFilespec"
	    return 0
	fi
    done
    return 1
}

parseDefinitionGroup()
{
    local definitionGroupFilespec="${1:?}"; shift
    let physicalLineCnt=0
    while IFS=$'\n' read -r line
    do
	let physicalLineCnt+=1
	while [[ "$line" =~ \\$ ]]
	do
	    let physicalLineCnt+=1
	    IFS=$'\n' read -r nextLine
	    line="${line%\\}$nextLine"
	done
	[[ "$line" =~ ^[[:space:]]*# ]] && continue
	[[ "$line" =~ ^[[:space:]]*$ ]] && continue

	testDefinitionGroupFilter "$line"
	case $? in
	    1)	continue;;	# This is a definition group filter, but it did not filter.
	    2)	return;;	# The filter applies; skip the entire remainder of the definition group file.
	esac

	if [ ${#selections[@]} -eq 0 ]; then
	    definitions+=("$line")
	else
	    items="${line%%[	 ]#*}"
	    comment="${line#"$items"}"
	    comment="${comment##+([	 ])#*([	 ])}"
	    if [ -n "$comment" ]; then
		subject="$comment"  # Note: Do not eval the comment here, as that would make it much harder to exactly match the selection.
	    else
		eval "set -- $items"
		subject="$(getSubjectFromItems "$@")"
	    fi

	    contains "$subject" "${selections[@]}" && \
		definitions+=("$line")
	fi

    done < "$definitionGroupFilespec"
}

testDefinitionGroupFilter()
{
    local line="$1"; shift
    eval "set -- ${line%%[	 ]#*}"
    local lastDefinitionGroupFilterItem= item
    for item
    do
	local filter="${item#*:}"
	local prefix="${item%"$filter"}"
	if contains "$prefix" "${!definitionGroupFilterTypeRegistry[@]}"; then
	    lastDefinitionGroupFilterItem="$item"
	    local definitionGroupFilterFunction="${definitionGroupFilterTypeRegistry["$prefix"]}"
	    if [ -n "$definitionGroupFilterFunction" ]; then
		"isDefinitionGroupAcceptedBy${definitionGroupFilterFunction}" "$filter" "group $definitionGroup, after line $physicalLineCnt" && \
		    return 1	# (At least) one definition group filter in this line passes.
	    fi
	elif [ -n "$lastDefinitionGroupFilterItem" ]; then
	    printf >&2 'ERROR: Definition group filter types (%s) must not be mixed with other items (%s) in a single definition.\n' "$lastDefinitionGroupFilterItem" "$item"
	    exit 3
	else
	    return 0	# If the first item isn't a definition group filter, the other's cannot be such, neither. We'll catch any in the later processing stages.
	fi
    done
    [ -z "$lastDefinitionGroupFilterItem" ] || return 2	# None of the definition group filters passed; skip the entire definition group file.
}

isDefinitionGroupCompletelyFiltered()
{
    local definitionGroup="${1:?}"; shift
    local definitionGroupFilespec; definitionGroupFilespec="$(getDefinitionGroupFilespec "$definitionGroup")" || return 1

    typeset -a definitions=()
    parseDefinitionGroup "$definitionGroupFilespec"
    [ ${#definitions[@]} -eq 0 ]
}

isDefinitionGroupDir()
{
    local group="${1:?}"; shift
    local dirspec; for dirspec in "${definitionDirspecs[@]}"
    do
	[ -d "${dirspec}/${group}" ] && return 0
    done
    return 1
}
typeset -a acceptedGroups=()
addAllAcceptedGroups()
{
    typeset -a groups=()
    readarray -t groups < <(for dirspec in "${definitionDirspecs[@]}"
	do
	    cd "$dirspec" && find . -not -path '*/\.*' -print
	done | sort | sed -e 's#^\./##'
    )
    typeset -a filteredGroups=()
    local group; for group in "${groups[@]}"
    do
	contains "$group" "${filteredGroups[@]}" && continue

	local groupSubject="${group##+([0-9])}"	# Leading digits are used for ordering; drop them for querying the user and recalling as they are irrelevant to them and may be subject to change.
	local setupAppendix=''	# This may be modified by definition group filters (through isDefinitionGroupCompletelyFiltered()); reset it on every iteration here.
	if isDefinitionGroupDir "${group}"; then
	    groupDirectoryGroupCount=$(countGlob "${group}/*" "${groups[@]}")
	    ! isDefinitionGroupCompletelyFiltered "${group}/${GROUPDIR_FILTER_FILENAME}" && \
		if [ $groupDirectoryGroupCount -gt 1 ]; then
		    # Ignore a group directory that has only one group in it; the query for the group itself will suffice.
		    $obtainGroups --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --timespan "$SETUPSOFTWARE_GROUP_VALID_TIMESPAN" --subject "$groupSubject" --verb "directory (with $groupDirectoryGroupCount groups) is not" --state 'chosen' --action 'consider it'
		fi || \
		readarray -O ${#filteredGroups[@]} -t filteredGroups < <(filterGlob "${group}/*" "${groups[@]}")
	    continue
	fi

	isDefinitionGroupCompletelyFiltered "$group" && continue

	$obtainGroups --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --timespan "$SETUPSOFTWARE_GROUP_VALID_TIMESPAN" --subject "$groupSubject" --verb 'is not' --state 'chosen' --action 'consider it' && \
	    acceptedGroups+=("$group")
    done
}

database()
{
    # Note: No --namespace "$setupName" here, because the information usually is
    # system scoped (e.g. for the build-dep type). If clients want this scoped
    # to the setup, they can pass the arguments themselves.
    picoDB --base-type data --table "$@"
}

onceMarker()
{
    executionMarker --base-type data --namespace "$setupName" --group postinstall-or-once "$@"
}

createSetupName()
{
    setupName="$(basename -- "$(dirname -- "$(simplifyPath "${1:?}")")")"
    setupName="setup-${setupName#setup-}"
}

configUsageNative()
{
    # Note: Do not delegate to configUsage$nativePackageManager().
    cat <<HELPTEXT
Items without a prefix refer to packages installed via the distribution's
package manager (${nativePackageManager,}).
HELPTEXT
}
configUsageConfig()
{
    cat <<'HELPTEXT'
config: meta items supply special (type-specific) configuration to the non-meta
non-pre/postinstall item following it in the current definition if that item is
missing, but has now been selected. The configuration is available to both
add*() and install() functions. If there are multiple configurations for an
item, they are concatenated, separated by a newline. The format itself is
undefined, but needs to be a single line, and often is in the form
VARIABLE=VALUE, so that it can simply be eval'd by the type.
HELPTEXT
}
configUsageDecorate()
{
    cat <<'HELPTEXT'
decorate: meta items either prepend CMD-PREFIX to or replace all occurrences of
{} in CMD-DECORATION with the quoted installation command (and possibly a check
command as well if the type has such) of the non-meta non-pre/postinstall item
following it in the current definition if that item is missing, but has now been
selected.
The same item (if it appears multiple times) must be decorated consistently, or
individual items may go undecorated; a mixture of decorations is not supported.
Types that process multiple items with a single install command may not accept
decorations, or a single decoration that then applies to the whole set of items,
or may split off decorated items into separate install commands.
HELPTEXT
}
configUsagePreinstall()
{
    cat <<'HELPTEXT'
preinstall: items consist of an ACTION that is one of the following:
- an EXECUTABLE-COMMAND (potentially followed by command-line arguments) in the
  ./etc/preinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the preinstallation steps
- a TEXT-FILE in the ./etc/preinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual pre-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a PREINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A preinstall item runs (before other installation actions) if the non-meta
non-pre/postinstall item preceding it in the current definition is missing, but
has now been selected.
HELPTEXT
}
configUsagePostinstall()
{
    cat <<'HELPTEXT'
postinstall: items consist of an ACTION that is one of the following:
- an EXECUTABLE-COMMAND (potentially followed by command-line arguments) in the
  ./etc/postinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the postinstallation steps
- a TEXT-FILE in the ./etc/postinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual post-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a POSTINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
A postinstall item runs if the non-meta non-pre/postinstall item preceding it in
the current definition was missing, but has been successfully installed by the
installation commands.
HELPTEXT
}
configUsagePostinstallOrOnce()
{
    cat <<'HELPTEXT'
postinstall-or-once: items consist of [ID:]ACTION where the latter is one of the
following:
- an EXECUTABLE-COMMAND (potentially followed by command-line arguments) in the
  ./etc/postinstall directory tree that is invoked (prepend $SUDO if it needs to
  be invoked as root) and should then perform the postinstallation steps
- a TEXT-FILE in the ./etc/postinstall directory tree whose file name (without
  extension) is taken as a notification title and contents as notification to be
  displayed (presumably with instructions for manual post-installation steps)
  immediately and on each login until the user acknowledges it
- another ITEM (that is then executed as usual); for packages installed via the
  distribution's package manager, use the special "native:" prefix here
- a POSTINSTALL-EXPRESSION (whitespace must be escaped or the entire expression
  quoted!) that is eval'd (prepend $SUDO if it needs to be invoked as root)
Like a postinstall item, a postinstall-or-once item runs if the
non-meta non-pre/postinstall item preceding it in the current definition was
missing, but has been successfully installed by the installation commands.
Additionally, if the non-meta non-pre/postinstall item preceding it already
existed (e.g. it comes preinstalled), it will also run once (until it succeeds);
ID or ACTION itself is used for that uniqueness check.
HELPTEXT
}

typeset -A configuration=()
addConfig()
{
    local name="${1:?}"; shift
    local item="${name#*$'\n'}"
    # Convert the "config:VALUE\nITEM" to configuration[ITEM]=VALUE.
    # This can be queried by add${typeFunction}() and install${typeFunction}(),
    # and usually affects the rendering of the install command.
    local newValue="${name%%$'\n'*}"
    local existingValue="${configuration["$item"]}"
    configuration["$item"]="${existingValue}${existingValue:+$'\n'}${newValue}"
}

typeset -A decoration=()
addDecorate()
{
    local name="${1:?}"; shift
    local item="${name#*$'\n'}"
    # Convert the "decorate:VALUE\nITEM" to decoration[ITEM]=VALUE.
    # This can be queried by install${typeFunction}() and considered when
    # rendering the install command.
    local newValue="${name%%$'\n'*}"
    local existingValue="${decoration["$item"]}"
    if [ -n "$existingValue" -a "$existingValue" != "$newValue" ]; then
	printf >&2 'ERROR: Differing decoration "%s" and "%s" for %s\n' "$existingValue" "$newValue" "$item"
	exit 3
    fi
    decoration["$item"]="$newValue"
}
decorateCommand()
{
    local installCommand="${1:?}"; shift
    local decoration="$1"; shift

    if [[ "$decoration" =~ \{\} ]]; then
	printf -v quotedInstallCommand '%q' "$installCommand"
	printf %s "${decoration//\{\}/"$quotedInstallCommand"}"
    elif [ -n "$decoration" ]; then
	printf %s "${decoration}${decoration:+ }$installCommand"
    else
	printf %s "$installCommand"
    fi
}
submitInstallCommand()
{
    toBeInstalledCommands+=("$(decorateCommand "$@")")
}

typeset -a addedPreinstallArgs=()
addPreinstallArgs()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift
    addedPreinstallArgs+=(--pre "$item" --action "$action")
}
addPreinstall()
{
    local name="${1:?}"; shift
    if [ "${addedItems["${name#*$'\n'}"]}" ]; then
	# Convert the "preinstall:ACTION\nITEM" to --pre "$ITEM" --action
	# "$ACTION" and do a recursive invocation now, in order to print the
	# preinstallation commands before anything else. This cannot be done
	# within this script's scope, as preinstall items that reference another
	# ITEM will populate all the addedITEM* arrays, and everything will be
	# intermingled and later printed type by type in the static order, but
	# the purpose of preinstall is to execute stuff before anything else.
	addPreinstallArgs "${name#*$'\n'}" "${name%%$'\n'*}"
    fi
}
preinstallHook()
{
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && addedPreinstallArgs+=(--pre "$name" --action "${actionScript#"${dirspec}/"}")
	    done
	done
    set -o noglob
}
typeset -a addedPostinstallArgs=()
addPostinstall()
{
    local name="${1:?}"; shift
    local recursiveCallArg="$1"; shift

    # Convert the "postinstall:ACTION\nITEM" to
    # --post "$ITEM" --action "$ACTION".
    addedPostinstallArgs+=("${recursiveCallArg:---post}" "${name#*$'\n'}" --action "${name%%$'\n'*}" "$@")
}
typeset -a addedPostinstallContextArgs=()
addPostinstallContextCommand()
{
    [ $# -gt 0 ] || exit 3
    printf -v quotedContextCommand '%q ' "$@"; quotedContextCommand="${quotedContextCommand% }"
    addedPostinstallContextArgs+=(--post-context "$quotedContextCommand")
}
postinstallHook()
{
    set +o noglob
	local name="${1:?}"; shift
	local actionScript
	local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
	do
	    for actionScript in "${dirspec}/${name}"/*
	    do
		[ -x "$actionScript" ] && addedPostinstallArgs+=(--post "$name" --action "${actionScript#"${dirspec}/"}")
	    done
	done
    set -o noglob
}

invokeCheck()
{
    invocationMessage --or-passthrough --clear all --message "Checking${subject:+ }${subject}... " --initial-delay 500ms --spinner --render-timer 1s --command "${1:?}"
}

hasItem()
{
    local item="${1:?}"; shift
    local name="${item#*:}"
    local prefix="${item%"$name"}"

    local typeFunction="${typeRegistry["${prefix:-native:}"]}"
    if [ -n "$typeFunction" ]; then
	"has${typeFunction}" "$name"
    else
	printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	exit 3
    fi
}

typeset -A cachedDecisions=()
memoizeAndCacheDecision()
{
    local subject
    typeset -a memoizeDecisionArgs=()
    while [ $# -ne 0 ]
    do
	case "$1" in
	    --help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	    --subject|-s)	memoizeDecisionArgs+=("$1" "$2"); subject="$2"; shift; shift;;
	    --)			memoizeDecisionArgs+=("$1"); shift; break;;
	    *)			memoizeDecisionArgs+=("$1"); shift;;
	esac
    done

    [ -n "${cachedDecisions["$subject"]}" ] && \
	return ${cachedDecisions["$subject"]}

    memoizeDecision "${memoizeDecisionArgs[@]}" "$@"; local status=$?
    cachedDecisions["$subject"]=$status
    return $status
}

askTo()
{
    $obtainSelection --timespan "$SETUPSOFTWARE_DEFINITION_VALID_TIMESPAN" --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" "$@"
}
askToInstall()
{
    askTo --subject "${1:?}" --verb 'is not yet' --state installed --action 'install it'
}

isAvailableNative()
{
    isAvailable$nativePackageManager "$@"
}
isAvailableOrUserAcceptsNative()
{
    local isPreinstall; if [ "$1" = --preinstall ]; then shift; isPreinstall=t; fi
    local packageManagerExecutable="${1:?}"; shift
    local packageManagerPackageName="${1:-$packageManagerExecutable}"; shift
    local packageManagerSubject="${1:-$packageManagerPackageName}"; shift

    if isAvailableNative "$packageManagerPackageName" || exists "$packageManagerExecutable"; then
	return
    fi

    if askToInstall "$packageManagerSubject"; then
	if [ "$isPreinstall" ]; then
	    addPreinstallArgs dummy "native:${packageManagerPackageName}"   # dummy ITEM is ignored for preinstall actions, anyway.
	else
	    addNative "$packageManagerPackageName"
	fi
    else
	return 1
    fi
}
typeset -A dependency=()
isDependencyAvailableOrUserAcceptsNative()
{
    local dependencyExecutable="${1:?}"; shift
    local dependencyPackageName="${1:-$dependencyExecutable}"; shift
    local dependencySubject="${1:-$dependencyPackageName}"; shift
    local dependencyInstallCommand="$1"; shift

    exists "$dependencyExecutable" && return 0
    if [ ! "${dependency["$dependencyExecutable"]}" ]; then
	dependency["$dependencyExecutable"]=t
	askToInstall "$dependencySubject" || return 1

	preinstallHook "$dependencyPackageName"
	preInstall --execute

	if [ -n "$dependencyInstallCommand" ]; then
	    eval "$dependencyInstallCommand"
	else
	    addPreinstallArgs dummy "native:${dependencyPackageName}"	# dummy ITEM is ignored for preinstall actions, anyway.
	    preInstall --execute
	fi

	postinstallHook "$dependencyPackageName"
	postInstall --execute
    fi
    exists "$dependencyExecutable"
}

typeset -A addedItems=()
addItems()
{
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	local typeFunction="${typeRegistry["${prefix:-native:}"]}"
	if [ -n "$typeFunction" ]; then
	    "add${typeFunction}" "$name"
	elif [ "$prefix" = config: ]; then
	    addConfig "$name"
	elif [ "$prefix" = decorate: ]; then
	    addDecorate "$name"
	elif [ "$prefix" = preinstall: ]; then
	    addPreinstall "$name"
	elif [ "$prefix" = postinstall: ]; then
	    addPostinstall "$name"
	else
	    printf >&2 'ERROR: Invalid type: %s\n' "$prefix"
	    exit 3
	fi
	addedItems["$item"]=t	# Record all added items for the config, decorate type / preinstall check.
    done
}
hasOrAddItems()
{
    typeset -a missingItems=()
    local item; for item
    do
	local name="${item#*:}"
	local prefix="${item%"$name"}"
	if contains "$prefix" "${!definitionFilterTypeRegistry[@]}" "${!definitionGroupFilterTypeRegistry[@]}" config: decorate: preinstall: postinstall: postinstall-or-once:; then
	    printf >&2 'ERROR: Cannot use a %s type within a config / decorate / preinstall / postinstall[-or-once] item.\n' "$prefix"
	    exit 3
	fi

	[ ! "$isForce" ] && hasItem "$item"
	case $? in
	    0)	;;
	    98)	;;
	    99)	;;
	    *) missingItems+=("$item");;
	esac
    done

    [ ${#missingItems[@]} -eq 0 ] && return 1
    addItems "${missingItems[@]}"
}


installNative()
{
    # Do not invoke install$nativePackageManager(); as native types are
    # registered separately, their install function is invoked anyway, and that
    # will then process both native and prefixed items together.
    :
}

preInstall()
{
    [ ${#addedPreinstallArgs[@]} -gt 0 ] || return

    # When the preinstall actions are directly executed, but not the install
    # command we're generating, those actions must not produce anything on
    # stdout, as that might get captured by a client and then attempted to be
    # executed as install commands.
    local redirectStdoutToStderr; [ ! "$isExecute" ] && containsGlob '--execute|-e' "$@" && redirectStdoutToStderr='>&2'

    eval "\"\${scriptDir}/\${scriptName}\" \"\$@\" \"\${recursiveArgs[@]}\" \"\${addedPreinstallArgs[@]}\"${redirectStdoutToStderr:+ }${redirectStdoutToStderr}" && \
	addedPreinstallArgs=()
}
getPreinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local preinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${preinstallActionsDirspecs[@]}"
    do
	local preinstallFilespec="${dirspec}/${preinstallAction}"
	if [ $compareOp "$preinstallFilespec" ]; then
	    printf %s "$preinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPreInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift

    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if actionFilespec="$(getPreinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	printf -v quotedActionFilespec '%q' "$actionFilespec"
	local actionArgs="${actionWithoutSudo#"${actionWithoutSudoAndArgs}"}"
	addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${quotedActionFilespec}${actionArgs:+ }${actionArgs}"
    elif actionFilespec="$(getPreinstallFilespec -e "${action}")"; then
	local quotedPreinstallNotification; printf -v quotedPreinstallNotification %q "$actionFilespec"
	addUniqueToBeInstalledCommand "addLoginNotification --file $quotedPreinstallNotification --immediate --no-blocking-gui"
    else
	local name="${action#*:}"
	local prefix="${action%"$name"}"
	if [ "$prefix" = native: ]; then
	    # Note: Native packages would be indistinguishable from the
	    # PREINSTALL-EXPRESSION, as they have no prefix. Allow using a
	    # special "native:" prefix should it be necessary to install a
	    # package via the distribution's package manager before the main
	    # installation.
	    hasOrAddItems "${action#native:}"
	elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
	    hasOrAddItems "$action"
	else
	    addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
	fi
    fi || messagePrintf 'Skipping preinstall action, because %s indicated that no action is needed.\n' "$action"
}

postInstall()
{
    [ ${#addedPostinstallArgs[@]} -gt 0 ] || return

    typeset -a executeArg=(); [ "$isExecute" ] || executeArg=(--execute)    # Directly execute any postinstall commands; these already were authorized by the user when they executed the recursive script invocation. It's cumbersome when the execution just prints yet another command-line to be captured and executed, and especially when an automatic capture and execution is used (redirection into a file, into the bag, etc.), this printing then happens outside of the capture.
    local quotedPostInstallCommand
    printf -v quotedPostInstallCommand '%q ' "${scriptDir}/${scriptName}" "$@" "${executeArg[@]}" "${recursiveArgs[@]}" "${addedPostinstallContextArgs[@]}" "${addedPostinstallArgs[@]}"
    if addUniqueToBeInstalledCommand "${quotedPostInstallCommand% }"; then
	addedPostinstallArgs=()
	addedPostinstallContextArgs=()
    fi
}
getPostinstallFilespec()
{
    local compareOp="${1:?}"; shift
    local postinstallAction="${1:?}"; shift
    local dirspec; for dirspec in "${postinstallActionsDirspecs[@]}"
    do
	local postinstallFilespec="${dirspec}/${postinstallAction}"
	if [ $compareOp "$postinstallFilespec" ]; then
	    printf %s "$postinstallFilespec"
	    return 0
	fi
    done
    return 1
}
runPostInstallCheck()
{
    local item="${1:?}"; shift
    local action="${1:?}"; shift
    local actionWithoutSudo="${action#\$SUDO }"
    local sudoPrefix="${action%"$actionWithoutSudo"}"
    local actionWithoutSudoAndArgs="${actionWithoutSudo%% *}"
    local actionFilespec
    if [ "$isForce" ] || hasItem "$item"; then
	if actionFilespec="$(getPostinstallFilespec -x "${action}")"; then
	    printf -v quotedActionFilespec '%q' "$actionFilespec"
	    addUniqueToBeInstalledCommand "$quotedActionFilespec"
	elif actionFilespec="$(getPostinstallFilespec -x "${actionWithoutSudoAndArgs}")"; then
	    printf -v quotedActionFilespec '%q' "$actionFilespec"
	    local actionArgs="${actionWithoutSudo#"${actionWithoutSudoAndArgs}"}"
	    addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${quotedActionFilespec}${actionArgs:+ }${actionArgs}"
	elif actionFilespec="$(getPostinstallFilespec -e "${action}")"; then
	    local quotedPostinstallNotification; printf -v quotedPostinstallNotification %q "$actionFilespec"
	    addUniqueToBeInstalledCommand "addLoginNotification --file $quotedPostinstallNotification --immediate --no-blocking-gui"
	else
	    local name="${action#*:}"
	    local prefix="${action%"$name"}"
	    if [ "$prefix" = native: ]; then
		# Note: Native packages would be indistinguishable from the
		# POSTINSTALL-EXPRESSION, as they have no prefix. Allow using a
		# special "native:" prefix should it be necessary to install a
		# package via the distribution's package manager after a
		# successful installation.
		hasOrAddItems "${action#native:}" || \
		    messagePrintf 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    elif [ -n "$prefix" ] && [ -n "${typeRegistry["$prefix"]}" ]; then
		hasOrAddItems "$action" || \
		    messagePrintf 'Skipping postinstall action, because %s indicated that no action is needed.\n' "$action"
	    else
		addUniqueToBeInstalledCommand "${sudoPrefix:+${SUDO}${SUDO:+ }}${actionWithoutSudo}"
	    fi
	fi || return 1
    else
	messagePrintf 'Skipping postinstall action, because installation of %s was not successful.\n' "$item"
    fi
}

typeset -a toBeInstalledCommands=()
addUniqueToBeInstalledCommand()
{
    local command="${1:?}"; shift
    contains "$command" "${toBeInstalledCommands[@]}" && return 1
    toBeInstalledCommands+=("$command")
}
generateInstallCommands()
{
    preInstall

	typeset -a typeOrdering=("${!typeInstallOrder[@]}")
	readarray -t typeOrdering < <(printf '%s\n' "${typeOrdering[@]}" | sort -n)

	local order; for order in "${typeOrdering[@]}"
	do
	    local typeFunction="${typeInstallOrder["$order"]}"
	    "install${typeFunction}"
	done

    postInstall
}
printInstallCommands()
{
    [ ${#toBeInstalledCommands[@]} -eq 0 ] && return 1

    if [ "$isExecute" ]; then
	local installCommandline="$(joinBy '; ' "${toBeInstalledCommands[@]}")"
	set -e
	eval "$installCommandline" || exit $?	# Exit the script now because else installation failure would be treated as if there were no installation commands.
    else
	printf '%s\n' "${toBeInstalledCommands[@]}"
    fi
}
generateAndPrintInstallCommands()
{
    generateInstallCommands
    printInstallCommands
}

checkAndExit()
{
    [ $addedDefinitionCount -eq 0 ] && exit 0 || exit 1
}

readarray -t nativeTypeLibs < <(grep --files-with-matches 'nativeRegistry+=(' "${typeDir}"/*.sh)
for typeLib in "${nativeTypeLibs[@]}"
do
    source "$typeLib" || exit $?
done
case ${#nativeRegistry[@]} in
    0)	echo >&2 'ERROR: No native package management found.'; exit 3;;
    1)	readonly nativePackageManager="${nativeRegistry[0]}";;
    *)	printf >&2 'ERROR: Multiple native package managers found: %s\n' "$(joinBy ', ' "${nativeRegistry[@]}")"; exit 3;;
esac
for typeLib in "${typeDir}"/*.sh
do
    contains "$typeLib" "${nativeTypeLibs[@]}" && continue
    source "$typeLib" || exit $?
done
set -o noglob


installExitStatus=0
noopExitStatus=4
action=generateAndPrintInstallCommands
setupName=
setupAppendix=
obtainSelection=memoizeAndCacheDecision
isAddAll=
obtainGroups=memoizeDecision
typeset -a selections=()
typeset -a specialHandlingCommands=()
specialHandlingFinalCommand=
isBatch=
isPrint=
isExecute=
isQuiet=
isSilenceNoDefinitions=
isVerbose=
isForce=
typeset -a recursiveArgs=()
typeset -a additionalBaseDirs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--config-help|-H)
			shift
			typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
			eval 'printConfigUsage "$@"' "${pager:+|}" '"${pager[@]}"'
			exit 0
			;;
	--check)	shift; action=checkAndExit;;
	--dry-run)	shift; action=false;;
	--base-dir)	recursiveArgs+=("$1" "$2"); shift; baseDir="${1:?}"; shift;;
	--add-base-dir)	recursiveArgs+=("$1" "$2"); shift; additionalBaseDirs=("${1:?}" "${additionalBaseDirs[@]}"); shift;;
	--print|-p)	recursiveArgs+=("$1"); shift; isPrint=t;;
	--execute|-e)	recursiveArgs+=("$1"); shift; isExecute=t;;
	--quiet|-q)	recursiveArgs+=("$1"); shift; isQuiet=t; messagePrintf() { :; };;   # Optimization: Make messagePrintf() a no-op.
	--silence-no-definitions)
			shift; isSilenceNoDefinitions=t;;
	--verbose|-v)	recursiveArgs+=("$1"); shift; isVerbose=t;;
	--force|-f)	recursiveArgs+=("$1"); shift; isForce=t;;
	--yes|-y)	shift; obtainSelection=true;;
	--recall-only)	shift
			if [ "$isQuiet" ]; then
			    obtainSelection=silentRecallDecision
			else
			    obtainSelection=recallDecision
			fi
			;;
	--batch|-b)	recursiveArgs+=("$1"); shift; isBatch=t;;
	--select|-s)	shift; selections+=("$1"); shift;;
	--all|-a)	shift; isAddAll=t;;
	--group-recall-only)
			shift
			if [ "$isQuiet" ]; then
			    obtainGroups=silentRecallDecision
			else
			    obtainGroups=recallDecision
			fi
			;;
	--clear-group-recall)
			shift
			specialHandlingCommands+=('memoizeDecision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}-groups" --delete-all-decisions')
			;;
	--clear-definition-recall)
			shift
			specialHandlingCommands+=('memoizeDecision --memoize-group "${setupName}${setupAppendix:+-}${setupAppendix}" --delete-all-decisions')
			;;
	--name)		shift; setupName="${1:?}"; shift;;
	--database)	shift; database "$@"; exit $?;;
	--pre)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --pre %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			printf -v specialCommand 'runPreInstallCheck %q %q' "$item" "$specialAction"
			specialHandlingCommands+=("$specialCommand")
			specialHandlingFinalCommand='generateAndPrintInstallCommands'
			;;
	--post-context)	shift; eval "$1"; shift;;
	--post)		shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q' "$item" "$specialAction"
			specialHandlingCommands+=("${specialCommand% }")
			specialHandlingFinalCommand='generateAndPrintInstallCommands'
			;;
	--post-or-once)	shift; item="$1"; shift
			if [ "$1" != '--action' ]; then
			    printf >&2 'ASSERT: No --action following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; specialAction="$1"; shift
			if [ "$1" != '--id' ]; then
			    printf >&2 'ASSERT: No --id following after --post-or-once %q.\n' "$item"; exit 3
			fi
			shift; id="$1"; shift
			printf -v specialCommand 'runPostInstallCheck %q %q && onceMarker --update %q' "$item" "$specialAction" "$id"
			specialHandlingCommands+=("${specialCommand% }")
			specialHandlingFinalCommand='generateAndPrintInstallCommands'
			;;
	--)		shift; break;;
	-*)		if [ -n "${commandLineOptions["$1"]}" ]; then
			    "${commandLineOptions["$1"]}" "$1"
			    shift
			elif [ -n "${commandLineParameters["$1"]}" ]; then
			    "${commandLineParameters["$1"]}" "$1" "$2"
			    shift; shift
			else
			    echo "ERROR: Unknown option \"$1\"!"
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	*)		break;;
    esac
done
if [ "$isQuiet" ]; then
    if [ "$isVerbose" ]; then
	echo 'ERROR: Cannot combine -q|--quiet with -v|--verbose.'
	echo
	printUsage "$0"
	exit 2
    fi >&2
fi
if [ -t 1 ] && [ ! "$isExecute" ] && [ ! "$isPrint" ]; then
    echo >&2 'ERROR: Will not output installation commands to the terminal without -p|--print; either redirect output or directly execute via -e|--execute.'
    echo >&2
    printUsage "$0" >&2
    exit 2
elif [ "$isExecute" ] && [ "$isPrint" ]; then
    echo >&2 'ERROR: Cannot combine -e|--execute with -p|--print.'
    echo >&2
    printUsage "$0" >&2
    exit 2
fi
typeset -a preinstallActionsDirspecs=()
typeset -a postinstallActionsDirspecs=()
typeset -a definitionDirspecs=()

for dirspec in "${additionalBaseDirs[@]}" "$baseDir"
do
    [ -d "${dirspec}/preinstall" ]  && preinstallActionsDirspecs+=("${dirspec}/preinstall")
    [ -d "${dirspec}/postinstall" ] && postinstallActionsDirspecs+=("${dirspec}/postinstall")
    [ -d "${dirspec}/definitions" ] && definitionDirspecs+=("${dirspec}/definitions")
done
[ -n "$setupName" ] || createSetupName "${additionalBaseDirs[@]}" "$baseDir"

typeset -ra passedGroups=("$@"); set --
if [ "$isAddAll" ]; then
    addAllAcceptedGroups
    if [ ${#acceptedGroups[@]} -eq 0 ]; then
	exit 4
    else
	acceptedGroupsPlural=s; [ ${#acceptedGroups[@]} -eq 1 ] && acceptedGroupsPlural=
	messagePrintf '\nOkay, %d definition group%s selected. Now for the definitions themselves:\n\n' "${#acceptedGroups[@]}" "$acceptedGroupsPlural"
    fi
fi
if [ ${#specialHandlingCommands[@]} -gt 0 ]; then
    status=0
    for specialCommand in "${specialHandlingCommands[@]}"
    do
	eval "$specialCommand" || status=1
    done
    eval "$specialHandlingFinalCommand" || status=1
    exit $status
elif [ ! "$isAddAll" ] && [ ${#passedGroups[@]} -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

IFS=' '
typeset -a definitions=()
for definitionGroup in "${acceptedGroups[@]}" "${passedGroups[@]}"
do
    if [ "${definitionGroup:0:1}" != '.' ] && definitionGroupFilespec="$(getDefinitionGroupFilespec "$definitionGroup")"; then
	:
    elif [ -f "${definitionGroup}" ]; then
	definitionGroupFilespec="$definitionGroup"
    else
	printf >&2 'ERROR: Definition "%s" does not exist.\n' "$definitionGroup"
	exit 2
    fi

    parseDefinitionGroup "$definitionGroupFilespec"
done
if [ ${#definitions[@]} -eq 0 ]; then
    [ "$isSilenceNoDefinitions" ] || messagePrintf '%s\n' 'No definitions have been found.'
    exit 99
fi



let handledDefinitionCount=0
let missingDefinitionCount=0
let addedDefinitionCount=0
for definition in "${definitions[@]}"
do
    items="${definition%%[	 ]#*}"
    comment="${definition#"$items"}"
    comment="${comment#[	 ]#}"
    comment="${comment##[	 ]}"
    eval "set -- $items"
    if [ -n "$comment" ]; then
	subject="$(printf %s "$comment" | evalFile)"
    else
	subject="$(getSubjectFromItems "$@")"
    fi

    setupAppendix=''	# This may be modified by definition filters (through isDefinitionAcceptedBy${definitionFilterFunction}()); reset it for every definition here.
    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	[ -n "$prefix" ] || continue
	definitionFilterFunction="${definitionFilterTypeRegistry["$prefix"]}"
	if [ -n "$definitionFilterFunction" ]; then
	    "isDefinitionAcceptedBy${definitionFilterFunction}" "$name" "$definition" || \
		continue 2
	fi
    done

    let handledDefinitionCount+=1
    typeset -a missingItems=()
    typeset -a missingItemConfigurations=()
    lastRealItem=
    typeset -a lastConfigurations=()
    lastDecoration=
    lastMissingItem=
    let realItemCnt=0
    let missingRealItemCnt=0
    noMissingItemMessage="Already installed: $subject"
    for item
    do
	name="${item#*:}"
	prefix="${item%"$name"}"
	if contains "$prefix" "${!definitionFilterTypeRegistry[@]}"; then
	    continue    # Ignore; definition filters have already been handled.
	elif contains "$prefix" "${!definitionGroupFilterTypeRegistry[@]}"; then
	    printf >&2 'ERROR: Definition group filter types (like %s) must only appear the beginning of a definition group: %s.\n' "$prefix" "$item"
	    exit 3
	elif contains "$prefix" preinstall: postinstall:; then
	    if [ -z "$lastRealItem" ]; then
		printf >&2 'ERROR: No previous item before %s.\n' "$item"
		exit 3
	    elif [ "$lastRealItem" = "$lastMissingItem" ]; then
		# The preinstall action will run when the previous item will
		# be installed. The postinstall action will run when the
		# installation of the previous item was successful. To be
		# able to check that, we need that item as well, so append
		# it on a new line.
		missingItems+=("$item"$'\n'"$lastMissingItem")
	    fi
	elif [ "$prefix" = config: ]; then
	    # The configuration still needs the following real item to be
	    # complete; all we can do right now is storing the configuration
	    # itself.
	    lastConfigurations+=("$item")
	    continue
	elif [ "$prefix" = decorate: ]; then
	    lastDecoration="$item"
	    continue
	elif [ "$prefix" = postinstall-or-once: ]; then
	    if [ -z "$lastRealItem" ]; then
		printf >&2 'ERROR: No previous item before %s.\n' "$item"
		exit 3
	    else
		[ ! "$isForce" ] && hasItem "$lastRealItem"
		case $? in
		    0)	rest="${name#*:}"
			id="${name%"$rest"}"; id="${id%:}"; id="${id:-$rest}"
			escapedId="${id//	/ }"
			onceMarker --query "$escapedId"
			case $? in
			    0)	;;  # The item already is installed, and the check has been run already.
			    1|4)
				# The item already is installed, but the check did not run yet.
				addPostinstall "$rest"$'\n'"$lastRealItem" --post-or-once --id "$escapedId"
				noMissingItemMessage="Only postinstall required for $subject"
				;;
			    *)	exit 3;;
			esac
			;;
		    98)	;;
		    99)	;;
		    *)	if [ -n "$lastMissingItem" ]; then
			    # The postinstall action will run when the installation of the
			    # previous item was successful. To be able to check that, we
			    # need that item as well, so append it on a new line.
			    missingItems+=("postinstall:${name}"$'\n'"$lastMissingItem")
			fi
			;;
		esac
	    fi
	else
	    if [ -n "$lastDecoration" ]; then
		addDecorate "${lastDecoration#decorate:}"$'\n'"$item"
		lastDecoration=''
	    fi

	    lastRealItem="$item"
	    [ ! "$isForce" ] && hasItem "$item"
	    case $? in
		0)  lastMissingItem=;;
		98) # Just skip this item.
		    noMissingItemMessage="Just skipped items in $subject"
		    continue
		    ;;
		99) # If one item's state cannot not be determined, the entire definition should be skipped, as we cannot ensure the correct installation.
		    noMissingItemMessage="Skipped: $subject"
		    let handledDefinitionCount-=1
		    break
		    ;;
		*)  missingItems+=("$item")
		    lastMissingItem="$item"
		    let missingRealItemCnt+=1

		    # With the real item, we can finally assemble the complete
		    # configurations for it. Collect them in a separate array
		    # because
		    # a) we don't want them counted (like decorations, these are
		    #    just meta-information)
		    # b) these need to be added first, so that the add*()
		    #    function can already access the configuration
		    for c in "${lastConfigurations[@]}"
		    do
			missingItemConfigurations+=("$c"$'\n'"$item")
		    done
		    lastConfigurations=()
		    ;;
	    esac
	    let realItemCnt+=1
	fi
    done

    if [ ${#missingItems[@]} -eq 0 ]; then
	[ "$isVerbose" ] && messagePrintf '%s\n' "$noMissingItemMessage"
    else
	let missingDefinitionCount+=1
	what=
	itemVerb=are; [ -n "$comment" -o $realItemCnt -eq 1 ] && itemVerb=is
	itemAuxVerb=
	if [ $realItemCnt -gt $missingRealItemCnt ]; then
	    missingItemsPlural=s; [ $missingRealItemCnt -eq 1 ] && missingItemsPlural=
	    what="$missingRealItemCnt item${missingItemsPlural} missing: ${missingItems[*]}"
	elif [ $realItemCnt -gt 1 ]; then
	    what="all $missingRealItemCnt items are missing"
	fi

	if [ $missingRealItemCnt -eq 1 ] && [[ "${missingItems[0]}" =~ 'custom:once:' ]]; then
	    itemVerb='may or may'
	    itemAuxVerb=be
	fi

	if askTo --subject "$subject" --verb "$itemVerb not yet${itemAuxVerb:+ }$itemAuxVerb" --state "installed${what:+ (}${what}${what:+)}" --action 'install it'; then
	    let addedDefinitionCount+=1
	    # Add the configurations first, so that they are available to the
	    # add*() function for the real item already.
	    addItems "${missingItemConfigurations[@]}" "${missingItems[@]}"
	fi
    fi
done



$action && exit $installExitStatus

status=$noopExitStatus
if [ $handledDefinitionCount -gt 0 ]; then
    if [ $addedDefinitionCount -gt 0 ]; then
	definitionsVerb=are; definitionsPlural=s; [ $handledDefinitionCount -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	messagePrintf '%d out of %d offered definition%s would be installed.\n' "$addedDefinitionCount" "$handledDefinitionCount" "$definitionsPlural"
	status=$installExitStatus
    elif [ $missingDefinitionCount -gt 0 ]; then
	missingDefinitionCountPlural=s; missingDefinitionCountAuxilliaryVerb=were; [ $missingDefinitionCount -eq 1 ] && { missingDefinitionCountPlural=; missingDefinitionCountAuxilliaryVerb=was; }
	messagePrintf '%d not yet installed definition%s %s declined.\n' "$missingDefinitionCount" "$missingDefinitionCountPlural" "$missingDefinitionCountAuxilliaryVerb"
    else
	definitionsVerb=are; definitionsPlural=s; [ $handledDefinitionCount -eq 1 ] && { definitionsVerb=is; definitionsPlural= ; }
	messagePrintf '%d definition%s %s already installed.\n' "$handledDefinitionCount" "$definitionsPlural" "$definitionsVerb"
    fi
elif [ ${#definitions[@]} -gt 0 ]; then
    skippedDefinitionsVerb=have; skippedDefinitionsPlural=s; [ ${#definitions[@]} -eq 1 ] && { skippedDefinitionsVerb=has; skippedDefinitionsPlural= ; }
    messagePrintf '%d definition%s %s been skipped.\n' "${#definitions[@]}" "$skippedDefinitionsPlural" "$skippedDefinitionsVerb"
fi
exit $status
